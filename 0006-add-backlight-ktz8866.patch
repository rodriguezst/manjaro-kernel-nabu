From b9504e11dd82d2d645178daf7bbbc8f86183acac Mon Sep 17 00:00:00 2001
From: maverick <maverick_jia@sina.com>
Date: Sat, 10 Jun 2023 10:24:55 +0800
Subject: [PATCH 06/45] add backlight ktz8866

---
 drivers/video/backlight/Kconfig   |   9 ++
 drivers/video/backlight/Makefile  |   1 +
 drivers/video/backlight/ktz8866.c | 143 ++++++++++++++++++++++++++++++
 3 files changed, 153 insertions(+)
 create mode 100644 drivers/video/backlight/ktz8866.c

diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 936ba1e4d..6c2aeea67 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -190,6 +190,15 @@ config BACKLIGHT_KTD253
 	  which is a 1-wire GPIO-controlled backlight found in some mobile
 	  phones.
 
+config BACKLIGHT_KTZ8866
+	tristate "Backlight Driver for Kinetic KTZ8866"
+	depends on I2C
+	help
+	  say Y to enable the backlight driver for the Kinetic KTZ8866.
+
+	  The chip supports 2047 brightness levels.
+	  Which found in Xiaomi Mi Pad 5(Pro) tablet.
+
 config BACKLIGHT_LM3533
 	tristate "Backlight Driver for LM3533"
 	depends on MFD_LM3533
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index e815f3f1d..f70a819c3 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_BACKLIGHT_HP680)		+= hp680_bl.o
 obj-$(CONFIG_BACKLIGHT_HP700)		+= jornada720_bl.o
 obj-$(CONFIG_BACKLIGHT_IPAQ_MICRO)	+= ipaq_micro_bl.o
 obj-$(CONFIG_BACKLIGHT_KTD253)		+= ktd253-backlight.o
+obj-$(CONFIG_BACKLIGHT_KTZ8866)		+= ktz8866.o
 obj-$(CONFIG_BACKLIGHT_LM3533)		+= lm3533_bl.o
 obj-$(CONFIG_BACKLIGHT_LM3630A)		+= lm3630a_bl.o
 obj-$(CONFIG_BACKLIGHT_LM3639)		+= lm3639_bl.o
diff --git a/drivers/video/backlight/ktz8866.c b/drivers/video/backlight/ktz8866.c
new file mode 100644
index 000000000..74a3f8de8
--- /dev/null
+++ b/drivers/video/backlight/ktz8866.c
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Backlight driver for the Kinetic KTZ8866
+ * Jianhua Lu <lujianhua000@gmail.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#define KTZ8866_ENABLE_REG           0x08
+#define KTZ8866_BRIGHT_LB_REG        0x04
+#define KTZ8866_BRIGHT_HB_REG        0x05
+
+#define KTZ8866_ON_CMD               0x5F
+#define KTZ8866_OFF_CMD              0x1F
+
+#define KTZ8866_DEF_BRIGHT           1800
+#define KTZ8866_MAX_BRIGHT           2047
+
+/* Helper */
+#define HIGH_BYTE(x)                 (u8)((x >> 3) & 0xFF)
+#define LOW_BYTE(x)                  (u8)(x & 0x7)
+
+struct ktz8866 {
+	struct i2c_client *client;
+	struct backlight_device *backlight;
+	bool status;
+};
+
+int ktz8866_write(struct ktz8866 *ktz, u8 reg, u8 data)
+{
+	return i2c_smbus_write_byte_data(ktz->client, reg, data);
+}
+
+static int ktz8866_backlight_update_status(struct backlight_device *backlight)
+{
+	struct ktz8866 *ktz = bl_get_data(backlight);
+	int brightness = backlight_get_brightness(backlight);
+
+	if (!ktz->status && brightness > 0) {
+		ktz8866_write(ktz, KTZ8866_ENABLE_REG, KTZ8866_ON_CMD);
+		ktz->status = 1;
+	} else if (brightness == 0) {
+		ktz8866_write(ktz, KTZ8866_ENABLE_REG, KTZ8866_OFF_CMD);
+		ktz->status = 0;
+		msleep(10);
+	}
+
+	/* Set brightness */
+	ktz8866_write(ktz, KTZ8866_BRIGHT_HB_REG, HIGH_BYTE(brightness));
+	ktz8866_write(ktz, KTZ8866_BRIGHT_LB_REG, LOW_BYTE(brightness));
+
+	return 0;
+}
+
+static const struct backlight_ops ktz8866_backlight_ops = {
+	.options	= BL_CORE_SUSPENDRESUME,
+	.update_status	= ktz8866_backlight_update_status,
+};
+
+static int ktz8866_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
+{
+	struct backlight_device *backlight;
+	struct backlight_properties props;
+	struct ktz8866 *ktz;
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_warn(&client->dev,
+			 "ktz8866 I2C adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");
+		return -EIO;
+	}
+
+	ktz = devm_kzalloc(&client->dev, sizeof(*ktz), GFP_KERNEL);
+	if (!ktz)
+		return -ENOMEM;
+
+	ktz->client = client;
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = KTZ8866_MAX_BRIGHT;
+	props.brightness = clamp_t(unsigned int, KTZ8866_DEF_BRIGHT, 0,
+				   props.max_brightness);
+
+	backlight = devm_backlight_device_register(&client->dev, "ktz8866-backlight",
+					      &client->dev, ktz, &ktz8866_backlight_ops,
+					      &props);
+	if (IS_ERR(backlight)) {
+		dev_err(&client->dev, "failed to register backlight\n");
+		return PTR_ERR(backlight);
+	}
+
+	backlight_update_status(backlight);
+
+	i2c_set_clientdata(client, backlight);
+
+	return 0;
+}
+
+static void ktz8866_remove(struct i2c_client *client)
+{
+	struct backlight_device *backlight = i2c_get_clientdata(client);
+
+	backlight->props.brightness = 0;
+	backlight_update_status(backlight);
+
+
+}
+
+static const struct i2c_device_id ktz8866_ids[] = {
+	{ "ktz8866", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ktz8866_ids);
+
+static const struct of_device_id ktz8866_match_table[] = {
+	{ .compatible = "kinetic,ktz8866",},
+	{}
+};
+
+static struct i2c_driver ktz8866_driver = {
+	.driver = {
+		.name = "ktz8866",
+		.of_match_table = ktz8866_match_table,
+	},
+	.probe = ktz8866_probe,
+	.remove = ktz8866_remove,
+	.id_table = ktz8866_ids,
+};
+
+module_i2c_driver(ktz8866_driver);
+
+MODULE_AUTHOR("Jianhua Lu <lujianhua000@gmail.com>");
+MODULE_DESCRIPTION("Kinetic KTZ8866 Backlight Driver");
+MODULE_LICENSE("GPL");
-- 
2.34.1

