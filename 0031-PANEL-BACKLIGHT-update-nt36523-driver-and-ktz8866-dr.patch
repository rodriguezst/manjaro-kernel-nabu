From 4479802b481f2605445988b95cda2693a7179271 Mon Sep 17 00:00:00 2001
From: maverick <maverick_jia@sina.com>
Date: Mon, 18 Dec 2023 10:57:45 +0800
Subject: [PATCH 31/43] PANEL/BACKLIGHT: update nt36523 driver and ktz8866
 driver, move backlight power control to lcd panel

---
 .../dts/qcom/sm8150-xiaomi-nabu-maverick.dts  |   40 +-
 drivers/gpu/drm/panel/panel-novatek-nt36523.c | 1812 +++++++++++++----
 drivers/video/backlight/ktz8866.c             |  200 +-
 include/drm/drm_mipi_dsi.h                    |    1 -
 4 files changed, 1532 insertions(+), 521 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8150-xiaomi-nabu-maverick.dts b/arch/arm64/boot/dts/qcom/sm8150-xiaomi-nabu-maverick.dts
index 60fc65901..db8cb554e 100644
--- a/arch/arm64/boot/dts/qcom/sm8150-xiaomi-nabu-maverick.dts
+++ b/arch/arm64/boot/dts/qcom/sm8150-xiaomi-nabu-maverick.dts
@@ -162,29 +162,25 @@ vreg_s4a_1p8: pm8150-s4 {
 		vin-supply = <&vph_pwr>;
 	};
 
-	lcd_avdd_5p5: lcd-avdd-regulator {
+	bl_vddpos_5p5: bl-vddpos-regulator {
 		compatible = "regulator-fixed";
-		regulator-name = "lcd_avdd_5p5";
-
+		regulator-name = "bl_vddpos_5p5";
 		regulator-min-microvolt = <5500000>;
 		regulator-max-microvolt = <5500000>;
 		regulator-enable-ramp-delay = <233>;
-		gpio = <&tlmm 114 0>;
+		gpio = <&tlmm 114 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
-//		regulator-always-on;
 		regulator-boot-on;
 	};
 
-	lcd_avee_5p5: lcd-avee-regulator {
+	bl_vddneg_5p5: bl-vddneg-regulator {
 		compatible = "regulator-fixed";
-		regulator-name = "lcd_avee_5p5";
-
+		regulator-name = "bl_vddneg_5p5";
 		regulator-min-microvolt = <5500000>;
 		regulator-max-microvolt = <5500000>;
 		regulator-enable-ramp-delay = <233>;
-		gpio = <&tlmm 115 0>;
+		gpio = <&tlmm 115 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
-//		regulator-always-on;
 		regulator-boot-on;
 	};
 
@@ -571,8 +567,13 @@ &i2c0 {
 	backlight: backlight@11 {
 		compatible = "kinetic,ktz8866";
 		reg = <0x11>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&bl_en_state>;
+		vddpos-supply = <&bl_vddpos_5p5>;
+		vddneg-supply = <&bl_vddneg_5p5>;
+		enable-gpios = <&tlmm 27 GPIO_ACTIVE_HIGH>;
+		current-num-sinks = <5>;
+		kinetic,current-ramp-delay-ms = <128>;
+		kinetic,led-enable-ramp-delay-ms = <1>;
+		kinetic,enable-lcd-bias;
 	};
 };
 
@@ -731,17 +732,6 @@ pinconf-rx {
 		};
 	};
 
-	bl_en_state: bl-default-state {
-		bl-en {
-			pins = "gpio27";
-			function = "gpio";
-
-			drive-strength = <16>;
-			output-high;
-			bias-disable;
-		};
-	};
-
 	xiaomi_keyboard_mcu {
 		xiaomi_keyboard_suspend: xiaomi_keyboard_suspend {
 			mux {
@@ -804,15 +794,13 @@ &mdss_dsi0 {
 	qcom,sync-dual-dsi;
 
 	panel@0 {
-		compatible = "novatek,nt36523";
+		compatible = "xiaomi,nabu-csot-nt36523", "novatek,nt36523";
 		reg = <0>;
 
 		backlight = <&backlight>;
 		reset-gpios = <&tlmm 6 GPIO_ACTIVE_LOW>;
 
 		vddio-supply = <&vreg_l14a_1p88>;
-		avdd-supply = <&lcd_avdd_5p5>;
-		avee-supply = <&lcd_avee_5p5>;
 
 		#address-cells = <1>;
 		#size-cells = <0>;
diff --git a/drivers/gpu/drm/panel/panel-novatek-nt36523.c b/drivers/gpu/drm/panel/panel-novatek-nt36523.c
index 66c652bb5..5ffb09382 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt36523.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt36523.c
@@ -2,82 +2,63 @@
 /*
  * Novatek NT36523 DriverIC panels driver
  *
- * Copyright (c) 2022 Jianhua Lu <lujianhua000@gmail.com>
+ * Copyright (c) 2022, 2023 Jianhua Lu <lujianhua000@gmail.com>
  */
 
+#include <linux/backlight.h>
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/regulator/consumer.h>
 
+#include <video/mipi_display.h>
+
 #include <drm/drm_connector.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_panel.h>
 
-enum dsi_cmd_type {
-	INIT_DCS_CMD,
-	DELAY_CMD,
-};
+#define DSI_NUM_MIN 1
 
-struct panel_init_cmd {
-	enum dsi_cmd_type type;
-	size_t len;
-	const char *data;
-};
+#define mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, cmd, seq...)        \
+		do {                                                 \
+			mipi_dsi_dcs_write_seq(dsi0, cmd, seq);      \
+			mipi_dsi_dcs_write_seq(dsi1, cmd, seq);      \
+		} while (0)
 
-#define _INIT_DCS_CMD(...) { \
-	.type = INIT_DCS_CMD, \
-	.len = sizeof((char[]){__VA_ARGS__}), \
-	.data = (char[]){__VA_ARGS__} }
-
-#define _INIT_DELAY_CMD(...) { \
-	.type = DELAY_CMD,\
-	.len = sizeof((char[]){__VA_ARGS__}), \
-	.data = (char[]){__VA_ARGS__} }
+struct panel_info {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi[2];
+	const struct panel_desc *desc;
+	enum drm_panel_orientation orientation;
 
-struct panel_desc {
-	const struct drm_display_mode *modes;
-	const struct mipi_dsi_device_info dsi_info;
+	struct gpio_desc *reset_gpio;
+	struct backlight_device *backlight;
+	struct regulator *vddio;
 
-	unsigned int bpc;
+	bool prepared;
+};
 
+struct panel_desc {
 	unsigned int width_mm;
 	unsigned int height_mm;
 
-	enum mipi_dsi_pixel_format format;
-	unsigned long mode_flags;
-
-	bool is_dual_dsi;
-
+	unsigned int bpc;
 	unsigned int lanes;
-};
-
-static const char * const nt36523_regulator_names[] = {
-	"vddio",
-	"avdd",
-	"avee",
-};
-
-static unsigned long const nt36523_regulator_enable_loads[] = {
-	62000,
-	100000,
-	100000
-};
-
-struct panel_info {
-	struct drm_panel panel;
-	struct mipi_dsi_device *dsi[2];
-	const struct panel_desc *desc;
-	struct regulator_bulk_data supplies[ARRAY_SIZE(nt36523_regulator_names)];
+	unsigned long mode_flags;
+	enum mipi_dsi_pixel_format format;
 
-	struct backlight_device *backlight;
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct mipi_dsi_device_info dsi_info;
+	int (*init_sequence)(struct panel_info *pinfo);
 
-	struct gpio_desc *reset_gpio;
-	bool prepared;
+	bool is_dual_dsi;
+	bool has_dcs_backlight;
 };
 
 static inline struct panel_info *to_panel_info(struct drm_panel *panel)
@@ -85,345 +66,1275 @@ static inline struct panel_info *to_panel_info(struct drm_panel *panel)
 	return container_of(panel, struct panel_info, panel);
 }
 
-static int send_panel_init_cmds(struct drm_panel *panel, const struct panel_init_cmd *cmds)
+static int elish_boe_init_sequence(struct panel_info *pinfo)
 {
-	struct panel_info *pinfo = to_panel_info(panel);
-	unsigned int i = 0;
-	int err;
-
-	if (!cmds)
-		return -EFAULT;
-
-	for (i = 0; cmds[i].len != 0; i++) {
-		const struct panel_init_cmd *cmd = &cmds[i];
-
-		switch(cmd->type) {
-			case DELAY_CMD:
-				msleep(cmd->data[0]);
-				err = 0;
-				break;
-			case INIT_DCS_CMD:
-				err = mipi_dsi_dcs_write(pinfo->dsi[0], cmd->data[0],
-						cmd->len <= 1 ? NULL : &cmd->data[1],
-						cmd->len - 1);
-				if(pinfo->desc->is_dual_dsi) {
-					if (err < 0) {
-						dev_err(panel->dev,
-								"failed to write command %u\n", i);
-						return err;
-					}
-					err = mipi_dsi_dcs_write(pinfo->dsi[1], cmd->data[0],
-							cmd->len <= 1 ? NULL : &cmd->data[1],
-							cmd->len - 1);
-				}
-				break;
-			default:
-				err = -EINVAL;
-
-		}
-		if (err < 0) {
-			dev_err(panel->dev,
-					"failed to write command %u\n", i);
-			return err;
-		}
-	}
+	struct mipi_dsi_device *dsi0 = pinfo->dsi[0];
+	struct mipi_dsi_device *dsi1 = pinfo->dsi[1];
+	/* No datasheet, so write magic init sequence directly */
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x05);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x18, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0x84);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x05, 0x2d);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x06, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x07, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x08, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0x45);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x12, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x15, 0x83);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x16, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29, 0x0a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x31, 0xfe);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x32, 0xfd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x33, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x34, 0xf8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0xf5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x36, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x37, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x38, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0xec);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3d, 0xe9);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3f, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x40, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x41, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x45, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x46, 0xf4);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x47, 0xe7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x48, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x49, 0xcd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4a, 0xc0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4b, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4c, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4d, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4e, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x50, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x68);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x52, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x54, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0x0e);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x58, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x59, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5a, 0xf7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5b, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5c, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5d, 0xe3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5e, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5f, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x60, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x61, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x62, 0xcb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x63, 0xbf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x64, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x65, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x66, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x67, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x25, 0x47);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0x47);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0x47);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1a, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x84, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x85, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x91, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x92, 0x0f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x93, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x94, 0x18);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x95, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x96, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb0, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x1b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x24);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x27);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x31);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd1, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd2, 0x30);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xde, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xdf, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x81);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x22);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9f, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x6f, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x70, 0x11);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x73, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x74, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x76, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x77, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa0, 0x3f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa9, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xaa, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xab, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xad, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xba, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbe, 0x04);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbf, 0x49);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc0, 0x04);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc1, 0x59);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc2, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc5, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc6, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc7, 0x48);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xca, 0x43);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcb, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xce, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcf, 0x43);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd3, 0x43);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd7, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xdc, 0x43);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xdd, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xe1, 0x43);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xe2, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xf2, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xf3, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xf4, 0x48);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x13, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x14, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbc, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbd, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x97, 0x3c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x98, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x99, 0x95);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9a, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9b, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9c, 0x0b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9d, 0x0a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9e, 0x90);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x22);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9f, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa3, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x14, 0x60);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x16, 0xc0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xd0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x02, 0xaf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0xee);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1d, 0x09);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x0f, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x2c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0x03, 0xac, 0x1a, 0x04, 0x04);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11);
+	msleep(70);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29);
 
 	return 0;
 }
 
-static const struct panel_init_cmd nt36523_on_cmd[] = {
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0xB9, 0x05),
-	_INIT_DCS_CMD(0xFF, 0x20),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x18, 0x40),
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0xB9, 0x02),
-	_INIT_DCS_CMD(0xFF, 0xD0),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x02, 0xAF),
-	_INIT_DCS_CMD(0x00, 0x30),
-	_INIT_DCS_CMD(0x09, 0xEE),
-	_INIT_DCS_CMD(0x1C, 0x99),
-	_INIT_DCS_CMD(0x1D, 0x09),
-	_INIT_DCS_CMD(0xFF, 0xF0),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x3A, 0x08),
-	_INIT_DCS_CMD(0xFF, 0xE0),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x4F, 0x02),
-	_INIT_DCS_CMD(0xFF, 0x20),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x58, 0x40),
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x35, 0x00),
-	/* CABC SETTING CFG Start*/
-	_INIT_DCS_CMD(0xFF, 0x23),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x00, 0x80),
-	_INIT_DCS_CMD(0x01, 0x84),
-	_INIT_DCS_CMD(0x05, 0x2D),
-	_INIT_DCS_CMD(0x06, 0x00),
-	_INIT_DCS_CMD(0x07, 0x00),
-	_INIT_DCS_CMD(0x08, 0x01),
-	_INIT_DCS_CMD(0x09, 0x45),
-	_INIT_DCS_CMD(0x11, 0x02),
-	_INIT_DCS_CMD(0x12, 0x80),
-	_INIT_DCS_CMD(0x15, 0x83),
-	_INIT_DCS_CMD(0x16, 0x0C),
-	_INIT_DCS_CMD(0x29, 0x0A),
-	_INIT_DCS_CMD(0x30, 0xFF),
-	_INIT_DCS_CMD(0x31, 0xFE),
-	_INIT_DCS_CMD(0x32, 0xFD),
-	_INIT_DCS_CMD(0x33, 0xFB),
-	_INIT_DCS_CMD(0x34, 0xF8),
-	_INIT_DCS_CMD(0x35, 0xF5),
-	_INIT_DCS_CMD(0x36, 0xF3),
-	_INIT_DCS_CMD(0x37, 0xF2),
-	_INIT_DCS_CMD(0x38, 0xF2),
-	_INIT_DCS_CMD(0x39, 0xF2),
-	_INIT_DCS_CMD(0x3A, 0xEF),
-	_INIT_DCS_CMD(0x3B, 0xEC),
-	_INIT_DCS_CMD(0x3D, 0xE9),
-	_INIT_DCS_CMD(0x3F, 0xE5),
-	_INIT_DCS_CMD(0x40, 0xE5),
-	_INIT_DCS_CMD(0x41, 0xE5),
-	_INIT_DCS_CMD(0x2A, 0x13),
-	_INIT_DCS_CMD(0x45, 0xFF),
-	_INIT_DCS_CMD(0x46, 0xF4),
-	_INIT_DCS_CMD(0x47, 0xE7),
-	_INIT_DCS_CMD(0x48, 0xDA),
-	_INIT_DCS_CMD(0x49, 0xCD),
-	_INIT_DCS_CMD(0x4A, 0xC0),
-	_INIT_DCS_CMD(0x4B, 0xB3),
-	_INIT_DCS_CMD(0x4C, 0xB2),
-	_INIT_DCS_CMD(0x4D, 0xB2),
-	_INIT_DCS_CMD(0x4E, 0xB2),
-	_INIT_DCS_CMD(0x4F, 0x99),
-	_INIT_DCS_CMD(0x50, 0x80),
-	_INIT_DCS_CMD(0x51, 0x68),
-	_INIT_DCS_CMD(0x52, 0x66),
-	_INIT_DCS_CMD(0x53, 0x66),
-	_INIT_DCS_CMD(0x54, 0x66),
-	_INIT_DCS_CMD(0x2B, 0x0E),
-	_INIT_DCS_CMD(0x58, 0xFF),
-	_INIT_DCS_CMD(0x59, 0xFB),
-	_INIT_DCS_CMD(0x5A, 0xF7),
-	_INIT_DCS_CMD(0x5B, 0xF3),
-	_INIT_DCS_CMD(0x5C, 0xEF),
-	_INIT_DCS_CMD(0x5D, 0xE3),
-	_INIT_DCS_CMD(0x5E, 0xDA),
-	_INIT_DCS_CMD(0x5F, 0xD8),
-	_INIT_DCS_CMD(0x60, 0xD8),
-	_INIT_DCS_CMD(0x61, 0xD8),
-	_INIT_DCS_CMD(0x62, 0xCB),
-	_INIT_DCS_CMD(0x63, 0xBF),
-	_INIT_DCS_CMD(0x64, 0xB3),
-	_INIT_DCS_CMD(0x65, 0xB2),
-	_INIT_DCS_CMD(0x66, 0xB2),
-	_INIT_DCS_CMD(0x67, 0xB2),
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x51, 0x0F, 0xFF),
-	_INIT_DCS_CMD(0x53, 0x2C),
-	/* CABC SETTING CFG END */
-	_INIT_DCS_CMD(0x55, 0x00),
-	_INIT_DCS_CMD(0xBB, 0x13),
-	_INIT_DCS_CMD(0x3B, 0x03, 0xAC, 0x1A, 0x04, 0x04),
-	/* 30HZ pen code Start*/
-	_INIT_DCS_CMD(0xFF, 0x2A),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x25, 0x46),
-	_INIT_DCS_CMD(0x30, 0x46),
-	_INIT_DCS_CMD(0x39, 0x46),
-	_INIT_DCS_CMD(0xFF, 0x26),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x01, 0xB0),
-	_INIT_DCS_CMD(0x19, 0x10),
-	_INIT_DCS_CMD(0x1A, 0xE0),
-	_INIT_DCS_CMD(0x1B, 0x10),
-	_INIT_DCS_CMD(0x1C, 0x00),
-	_INIT_DCS_CMD(0x2A, 0x10),
-	_INIT_DCS_CMD(0x2B, 0xE0),
-	/* 30HZ pen code END*/
-	/* ESD code Start*/
-	_INIT_DCS_CMD(0xFF, 0xF0),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x84, 0x08),
-	_INIT_DCS_CMD(0x85, 0x0C),
-	_INIT_DCS_CMD(0xFF, 0x20),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x51, 0x00),
-	_INIT_DCS_CMD(0xFF, 0x25),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x91, 0x1F),
-	_INIT_DCS_CMD(0x92, 0x0F),
-	_INIT_DCS_CMD(0x93, 0x01),
-	_INIT_DCS_CMD(0x94, 0x18),
-	_INIT_DCS_CMD(0x95, 0x03),
-	_INIT_DCS_CMD(0x96, 0x01),
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0xB0, 0x01),
-	_INIT_DCS_CMD(0xFF, 0x25),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x19, 0x1F),
-	_INIT_DCS_CMD(0x1B, 0x1B),
-	_INIT_DCS_CMD(0xFF, 0x24),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0xB8, 0x28),
-	_INIT_DCS_CMD(0xFF, 0x27),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0xD0, 0x31),
-	_INIT_DCS_CMD(0xD1, 0x20),
-	_INIT_DCS_CMD(0xD4, 0x08),
-	_INIT_DCS_CMD(0xDE, 0x80),
-	_INIT_DCS_CMD(0xDF, 0x02),
-	_INIT_DCS_CMD(0xFF, 0x26),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x00, 0x81),
-	_INIT_DCS_CMD(0x01, 0xB0),
-	_INIT_DCS_CMD(0xFF, 0x22),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x6F, 0x01),
-	_INIT_DCS_CMD(0x70, 0x11),
-	_INIT_DCS_CMD(0x73, 0x01),
-	_INIT_DCS_CMD(0x74, 0x4D),
-	_INIT_DCS_CMD(0xA0, 0x3F),
-	_INIT_DCS_CMD(0xA9, 0x50),
-	_INIT_DCS_CMD(0xAA, 0x28),
-	_INIT_DCS_CMD(0xAB, 0x28),
-	_INIT_DCS_CMD(0xAD, 0x10),
-	_INIT_DCS_CMD(0xB8, 0x00),
-	_INIT_DCS_CMD(0xB9, 0x4B),
-	_INIT_DCS_CMD(0xBA, 0x96),
-	_INIT_DCS_CMD(0xBB, 0x4B),
-	_INIT_DCS_CMD(0xBE, 0x07),
-	_INIT_DCS_CMD(0xBF, 0x4B),
-	_INIT_DCS_CMD(0xC0, 0x07),
-	_INIT_DCS_CMD(0xC1, 0x5C),
-	_INIT_DCS_CMD(0xC2, 0x00),
-	_INIT_DCS_CMD(0xC5, 0x00),
-	_INIT_DCS_CMD(0xC6, 0x3F),
-	_INIT_DCS_CMD(0xC7, 0x00),
-	_INIT_DCS_CMD(0xCA, 0x08),
-	_INIT_DCS_CMD(0xCB, 0x40),
-	_INIT_DCS_CMD(0xCE, 0x00),
-	_INIT_DCS_CMD(0xCF, 0x08),
-	_INIT_DCS_CMD(0xD0, 0x40),
-	_INIT_DCS_CMD(0xD3, 0x08),
-	_INIT_DCS_CMD(0xD4, 0x40),
-	_INIT_DCS_CMD(0xFF, 0x25),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0xBC, 0x01),
-	_INIT_DCS_CMD(0xBD, 0x1C),
-	_INIT_DCS_CMD(0xFF, 0x2A),
-	_INIT_DCS_CMD(0xFB, 0x01),
-	_INIT_DCS_CMD(0x9A, 0x03),
-	_INIT_DCS_CMD(0xFF, 0x10),
-	_INIT_DCS_CMD(0x11),
-	_INIT_DELAY_CMD(70),
-	_INIT_DCS_CMD(0x29),
-	{},
-};
+static int elish_csot_init_sequence(struct panel_info *pinfo)
+{
+	struct mipi_dsi_device *dsi0 = pinfo->dsi[0];
+	struct mipi_dsi_device *dsi1 = pinfo->dsi[1];
+	/* No datasheet, so write magic init sequence directly */
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x05);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x18, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xd0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x02, 0xaf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x30);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0xee);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1d, 0x09);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x58, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0x84);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x05, 0x2d);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x06, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x07, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x08, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0x45);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x12, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x15, 0x83);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x16, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29, 0x0a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x31, 0xfe);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x32, 0xfd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x33, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x34, 0xf8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0xf5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x36, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x37, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x38, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0xec);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3d, 0xe9);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3f, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x40, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x41, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x45, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x46, 0xf4);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x47, 0xe7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x48, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x49, 0xcd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4a, 0xc0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4b, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4c, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4d, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4e, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x50, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x68);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x52, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x54, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0x0e);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x58, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x59, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5a, 0xf7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5b, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5c, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5d, 0xe3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5e, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5f, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x60, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x61, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x62, 0xcb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x63, 0xbf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x64, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x65, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x66, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x67, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x0f, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x2c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x55, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0x03, 0xac, 0x1a, 0x04, 0x04);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x25, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1a, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x84, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x85, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x91, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x92, 0x0f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x93, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x94, 0x18);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x95, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x96, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb0, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x1b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x24);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x27);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x31);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd1, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xde, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xdf, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x81);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x22);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x6f, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x70, 0x11);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x73, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x74, 0x4d);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa0, 0x3f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa9, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xaa, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xab, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xad, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xba, 0x96);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbe, 0x07);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbf, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc0, 0x07);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc1, 0x5c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc2, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc5, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc6, 0x3f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc7, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xca, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcb, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xce, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcf, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd3, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbc, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbd, 0x1c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9a, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11);
+	msleep(70);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29);
 
+	return 0;
+}
 
-static void nt36523_reset(struct panel_info *pinfo)
+static int nabu_csot_init_sequence(struct panel_info *pinfo)
 {
-	gpiod_set_value_cansleep(pinfo->reset_gpio, 1);
-	usleep_range(12000, 13000);
-	gpiod_set_value_cansleep(pinfo->reset_gpio, 0);
-	usleep_range(12000, 13000);
-	gpiod_set_value_cansleep(pinfo->reset_gpio, 1);
-	usleep_range(12000, 13000);
-	gpiod_set_value_cansleep(pinfo->reset_gpio, 0);
-	usleep_range(12000, 13000);
+	struct mipi_dsi_device *dsi0 = pinfo->dsi[0];
+	struct mipi_dsi_device *dsi1 = pinfo->dsi[1];
+	/* No datasheet, so write magic init sequence directly */
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x05);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x18, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xd0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x02, 0xaf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x30);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0xee);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1d, 0x09);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x23);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0x84);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x05, 0x2d);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x06, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x07, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x08, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x09, 0x45);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x12, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x15, 0x83);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x16, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29, 0x0a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x31, 0xfe);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x32, 0xfd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x33, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x34, 0xf8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x35, 0xf5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x36, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x37, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x38, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0xf2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3a, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0xec);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3d, 0xe9);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3f, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x40, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x41, 0xe5);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x45, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x46, 0xf4);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x47, 0xe7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x48, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x49, 0xcd);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4a, 0xc0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4b, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4c, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4d, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4e, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x4f, 0x99);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x50, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x68);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x52, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x54, 0x66);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0x0e);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x58, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x59, 0xfb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5a, 0xf7);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5b, 0xf3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5c, 0xef);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5d, 0xe3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5e, 0xda);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x5f, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x60, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x61, 0xd8);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x62, 0xcb);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x63, 0xbf);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x64, 0xb3);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x65, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x66, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x67, 0xb2);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x0f, 0xff);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x53, 0x24);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x55, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x13);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x3b, 0x03, 0xac, 0x1a, 0x04, 0x04);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x25, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x30, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x39, 0x46);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1a, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1c, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2a, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x2b, 0xe0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0xf0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x84, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x85, 0x0c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x51, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x91, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x92, 0x0f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x93, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x94, 0x18);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x95, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x96, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb0, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x19, 0x1f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x1b, 0x1b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x24);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x27);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x31);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xde, 0x80);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xdf, 0x02);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd1, 0x20);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x26);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x00, 0x81);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x01, 0xb0);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x22);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x6f, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x70, 0x11);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x73, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x74, 0x4d);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa0, 0x3f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xa9, 0x50);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xaa, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xab, 0x28);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xad, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb8, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xb9, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xba, 0x96);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbb, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbe, 0x07);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbf, 0x4b);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc0, 0x07);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc1, 0x5c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc2, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc5, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc6, 0x3f);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xc7, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xca, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcb, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xce, 0x00);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xcf, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd0, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd3, 0x08);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xd4, 0x40);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x25);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbc, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xbd, 0x1c);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x2a);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xfb, 0x01);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x9a, 0x03);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0xff, 0x10);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x11);
+	msleep(70);
+	mipi_dsi_dual_dcs_write_seq(dsi0, dsi1, 0x29);
+
+	return 0;
 }
 
-static int nt36523_off(struct panel_info *pinfo)
+static int j606f_boe_init_sequence(struct panel_info *pinfo)
 {
-	struct device *dev = &pinfo->dsi[0]->dev;
+	struct mipi_dsi_device *dsi = pinfo->dsi[0];
+	struct device *dev = &dsi->dev;
 	int ret;
 
-	ret = mipi_dsi_dcs_set_display_off(pinfo->dsi[0]);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x78);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0xa2);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00, 0x08, 0x00, 0x23, 0x00, 0x4d, 0x00, 0x6d, 0x00,
+			       0x89, 0x00, 0xa1, 0x00, 0xb6, 0x00, 0xc9);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x00, 0xda, 0x01, 0x13, 0x01, 0x3c, 0x01, 0x7e, 0x01,
+			       0xab, 0x01, 0xf7, 0x02, 0x2f, 0x02, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x02, 0x67, 0x02, 0xa6, 0x02, 0xd1, 0x03, 0x08, 0x03,
+			       0x2e, 0x03, 0x5b, 0x03, 0x6b, 0x03, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x03, 0x8e, 0x03, 0xa2, 0x03, 0xb7, 0x03, 0xe7, 0x03,
+			       0xfd, 0x03, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x00, 0x08, 0x00, 0x23, 0x00, 0x4d, 0x00, 0x6d, 0x00,
+			       0x89, 0x00, 0xa1, 0x00, 0xb6, 0x00, 0xc9);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00, 0xda, 0x01, 0x13, 0x01, 0x3c, 0x01, 0x7e, 0x01,
+			       0xab, 0x01, 0xf7, 0x02, 0x2f, 0x02, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x02, 0x67, 0x02, 0xa6, 0x02, 0xd1, 0x03, 0x08, 0x03,
+			       0x2e, 0x03, 0x5b, 0x03, 0x6b, 0x03, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x03, 0x8e, 0x03, 0xa2, 0x03, 0xb7, 0x03, 0xe7, 0x03,
+			       0xfd, 0x03, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x00, 0x08, 0x00, 0x23, 0x00, 0x4d, 0x00, 0x6d, 0x00,
+			       0x89, 0x00, 0xa1, 0x00, 0xb6, 0x00, 0xc9);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00, 0xda, 0x01, 0x13, 0x01, 0x3c, 0x01, 0x7e, 0x01,
+			       0xab, 0x01, 0xf7, 0x02, 0x2f, 0x02, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x02, 0x67, 0x02, 0xa6, 0x02, 0xd1, 0x03, 0x08, 0x03,
+			       0x2e, 0x03, 0x5b, 0x03, 0x6b, 0x03, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x03, 0x8e, 0x03, 0xa2, 0x03, 0xb7, 0x03, 0xe7, 0x03,
+			       0xfd, 0x03, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x45, 0x00, 0x65, 0x00,
+			       0x81, 0x00, 0x99, 0x00, 0xae, 0x00, 0xc1);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x00, 0xd2, 0x01, 0x0b, 0x01, 0x34, 0x01, 0x76, 0x01,
+			       0xa3, 0x01, 0xef, 0x02, 0x27, 0x02, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x02, 0x5f, 0x02, 0x9e, 0x02, 0xc9, 0x03, 0x00, 0x03,
+			       0x26, 0x03, 0x53, 0x03, 0x63, 0x03, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x03, 0x86, 0x03, 0x9a, 0x03, 0xaf, 0x03, 0xdf, 0x03,
+			       0xf5, 0x03, 0xf7);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x45, 0x00, 0x65, 0x00,
+			       0x81, 0x00, 0x99, 0x00, 0xae, 0x00, 0xc1);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00, 0xd2, 0x01, 0x0b, 0x01, 0x34, 0x01, 0x76, 0x01,
+			       0xa3, 0x01, 0xef, 0x02, 0x27, 0x02, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x02, 0x5f, 0x02, 0x9e, 0x02, 0xc9, 0x03, 0x00, 0x03,
+			       0x26, 0x03, 0x53, 0x03, 0x63, 0x03, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x03, 0x86, 0x03, 0x9a, 0x03, 0xaf, 0x03, 0xdf, 0x03,
+			       0xf5, 0x03, 0xf7);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x45, 0x00, 0x65, 0x00,
+			       0x81, 0x00, 0x99, 0x00, 0xae, 0x00, 0xc1);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00, 0xd2, 0x01, 0x0b, 0x01, 0x34, 0x01, 0x76, 0x01,
+			       0xa3, 0x01, 0xef, 0x02, 0x27, 0x02, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x02, 0x5f, 0x02, 0x9e, 0x02, 0xc9, 0x03, 0x00, 0x03,
+			       0x26, 0x03, 0x53, 0x03, 0x63, 0x03, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x03, 0x86, 0x03, 0x9a, 0x03, 0xaf, 0x03, 0xdf, 0x03,
+			       0xf5, 0x03, 0xf7);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x77);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_LUT, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0x44);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x32);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x44);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x00);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x9a);
 	if (ret < 0) {
-		dev_err(dev, "Failed to set display off: %d\n", ret);
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
 	}
 
-	if (pinfo->desc->is_dual_dsi) {
-		ret = mipi_dsi_dcs_set_display_off(pinfo->dsi[1]);
-		if (ret < 0) {
-			dev_err(dev, "Failed to set display off: %d\n", ret);
-		}
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0x42);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x9a);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x4c, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x4d, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x4e, 0x43);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 18);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
 	}
 
-	ret = mipi_dsi_dcs_enter_sleep_mode(pinfo->dsi[0]);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x82, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x00, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x3c);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6,
+			       0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
+			       0x05, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x5f);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0xc4);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0xe0);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_GET_SCANLINE, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0xd0);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_READ_PPS_START, 0xf3);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa1);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x51);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x65);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x00);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0xc3);
 	if (ret < 0) {
-		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
 	}
 
-	if (pinfo->desc->is_dual_dsi) {
-		ret = mipi_dsi_dcs_enter_sleep_mode(pinfo->dsi[1]);
-		if (ret < 0) {
-			dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
-		}
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x78);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x4e);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_READ_PPS_CONTINUE, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x53);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0xf8);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_LUT, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xe0);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x08);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
 	}
-	msleep(70);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x5d);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x5d);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x44);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x8d);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x75);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x02);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x5f, 0x1a, 0x04, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	usleep_range(10000, 11000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x05, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(100);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(30);
 
 	return 0;
 }
 
+static const struct drm_display_mode elish_boe_modes[] = {
+	{
+		/* There is only one 120 Hz timing, but it doesn't work perfectly, 104 Hz preferred */
+		.clock = (1600 + 60 + 8 + 60) * (2560 + 26 + 4 + 168) * 104 / 1000,
+		.hdisplay = 1600,
+		.hsync_start = 1600 + 60,
+		.hsync_end = 1600 + 60 + 8,
+		.htotal = 1600 + 60 + 8 + 60,
+		.vdisplay = 2560,
+		.vsync_start = 2560 + 26,
+		.vsync_end = 2560 + 26 + 4,
+		.vtotal = 2560 + 26 + 4 + 168,
+	},
+};
+
+static const struct drm_display_mode elish_csot_modes[] = {
+	{
+		/* There is only one 120 Hz timing, but it doesn't work perfectly, 104 Hz preferred */
+		.clock = (1600 + 200 + 40 + 52) * (2560 + 26 + 4 + 168) * 104 / 1000,
+		.hdisplay = 1600,
+		.hsync_start = 1600 + 200,
+		.hsync_end = 1600 + 200 + 40,
+		.htotal = 1600 + 200 + 40 + 52,
+		.vdisplay = 2560,
+		.vsync_start = 2560 + 26,
+		.vsync_end = 2560 + 26 + 4,
+		.vtotal = 2560 + 26 + 4 + 168,
+	},
+};
+
+static const struct drm_display_mode nabu_csot_modes[] = {
+	{
+		/* There is only one 120 Hz timing, but it doesn't work perfectly, 104 Hz preferred */
+		.clock = (1600 + 88 + 40 + 40) * (2560 + 26 + 4 + 168) * 104 / 1000,
+		.hdisplay = 1600,
+		.hsync_start = 1600 + 88,
+		.hsync_end = 1600 + 88 + 40,
+		.htotal = 1600 + 88 + 40 + 40,
+		.vdisplay = 2560,
+		.vsync_start = 2560 + 26,
+		.vsync_end = 2560 + 26 + 4,
+		.vtotal = 2560 + 26 + 4 + 168,
+	},
+};
+
+static const struct drm_display_mode j606f_boe_modes[] = {
+	{
+		.clock = (1200 + 58 + 2 + 60) * (2000 + 26 + 2 + 93) * 60 / 1000,
+		.hdisplay = 1200,
+		.hsync_start = 1200 + 58,
+		.hsync_end = 1200 + 58 + 2,
+		.htotal = 1200 + 58 + 2 + 60,
+		.vdisplay = 2000,
+		.vsync_start = 2000 + 26,
+		.vsync_end = 2000 + 26 + 2,
+		.vtotal = 2000 + 26 + 2 + 93,
+		.width_mm = 143,
+		.height_mm = 235,
+	},
+};
+
+static const struct panel_desc elish_boe_desc = {
+	.modes = elish_boe_modes,
+	.num_modes = ARRAY_SIZE(elish_boe_modes),
+	.dsi_info = {
+		.type = "BOE-elish",
+		.channel = 0,
+		.node = NULL,
+	},
+	.width_mm = 127,
+	.height_mm = 203,
+	.bpc = 8,
+	.lanes = 3,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.init_sequence = elish_boe_init_sequence,
+	.is_dual_dsi = true,
+};
+
+static const struct panel_desc elish_csot_desc = {
+	.modes = elish_csot_modes,
+	.num_modes = ARRAY_SIZE(elish_csot_modes),
+	.dsi_info = {
+		.type = "CSOT-elish",
+		.channel = 0,
+		.node = NULL,
+	},
+	.width_mm = 127,
+	.height_mm = 203,
+	.bpc = 8,
+	.lanes = 3,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.init_sequence = elish_csot_init_sequence,
+	.is_dual_dsi = true,
+};
+
+static const struct panel_desc nabu_csot_desc = {
+	.modes = nabu_csot_modes,
+	.num_modes = ARRAY_SIZE(nabu_csot_modes),
+	.dsi_info = {
+		.type = "CSOT-nabu",
+		.channel = 0,
+		.node = NULL,
+	},
+	.width_mm = 148,
+	.height_mm = 236,
+	.bpc = 8,
+	.lanes = 3,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.init_sequence = nabu_csot_init_sequence,
+	.is_dual_dsi = true,
+};
+
+static const struct panel_desc j606f_boe_desc = {
+	.modes = j606f_boe_modes,
+	.num_modes = ARRAY_SIZE(j606f_boe_modes),
+	.width_mm = 143,
+	.height_mm = 235,
+	.bpc = 8,
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		      MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
+	.init_sequence = j606f_boe_init_sequence,
+	.has_dcs_backlight = true,
+};
+
+static void nt36523_reset(struct panel_info *pinfo)
+{
+	gpiod_set_value_cansleep(pinfo->reset_gpio, 1);
+	usleep_range(12000, 13000);
+	gpiod_set_value_cansleep(pinfo->reset_gpio, 0);
+	usleep_range(12000, 13000);
+	gpiod_set_value_cansleep(pinfo->reset_gpio, 1);
+	usleep_range(12000, 13000);
+	gpiod_set_value_cansleep(pinfo->reset_gpio, 0);
+	usleep_range(12000, 13000);
+}
+
 static int nt36523_prepare(struct drm_panel *panel)
 {
 	struct panel_info *pinfo = to_panel_info(panel);
-	struct device *dev = &pinfo->dsi[0]->dev;
 	int ret;
 
 	if (pinfo->prepared)
 		return 0;
 
-	ret = regulator_bulk_enable(ARRAY_SIZE(pinfo->supplies), pinfo->supplies);
-	if (ret < 0)
+	ret = regulator_enable(pinfo->vddio);
+	if (ret) {
+		dev_err(panel->dev, "failed to enable vddio regulator: %d\n", ret);
 		return ret;
+	}
 
 	nt36523_reset(pinfo);
 
-	ret = send_panel_init_cmds(&pinfo->panel, nt36523_on_cmd);
+	ret = pinfo->desc->init_sequence(pinfo);
 	if (ret < 0) {
-		dev_err(dev, "Failed to initialize panel: %d\n", ret);
-		goto end;
+		regulator_disable(pinfo->vddio);
+		dev_err(panel->dev, "failed to initialize panel: %d\n", ret);
+		return ret;
 	}
 
 	pinfo->prepared = true;
 
-end:
-	if (ret < 0) {
-		regulator_bulk_disable(ARRAY_SIZE(pinfo->supplies), pinfo->supplies);
-		return ret;
+	return 0;
+}
+
+static int nt36523_disable(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+	int i, ret;
+
+	for (i = 0; i < DSI_NUM_MIN + pinfo->desc->is_dual_dsi; i++) {
+		ret = mipi_dsi_dcs_set_display_off(pinfo->dsi[i]);
+		if (ret < 0)
+			dev_err(&pinfo->dsi[i]->dev, "failed to set display off: %d\n", ret);
+	}
+
+	for (i = 0; i < DSI_NUM_MIN + pinfo->desc->is_dual_dsi; i++) {
+		ret = mipi_dsi_dcs_enter_sleep_mode(pinfo->dsi[i]);
+		if (ret < 0)
+			dev_err(&pinfo->dsi[i]->dev, "failed to enter sleep mode: %d\n", ret);
 	}
 
+	msleep(70);
+
 	return 0;
 }
 
 static int nt36523_unprepare(struct drm_panel *panel)
 {
 	struct panel_info *pinfo = to_panel_info(panel);
-	struct device *dev = &pinfo->dsi[0]->dev;
-	int ret;
 
 	if (!pinfo->prepared)
 		return 0;
 
-	ret = nt36523_off(pinfo);
-	if (ret < 0)
-		dev_err(dev, "Failed to deinitialize panel: %d\n", ret);
-
 	gpiod_set_value_cansleep(pinfo->reset_gpio, 1);
-	regulator_bulk_disable(ARRAY_SIZE(pinfo->supplies), pinfo->supplies);
+	regulator_disable(pinfo->vddio);
 
 	pinfo->prepared = false;
+
 	return 0;
 }
 
@@ -434,172 +1345,219 @@ static void nt36523_remove(struct mipi_dsi_device *dsi)
 
 	ret = mipi_dsi_detach(pinfo->dsi[0]);
 	if (ret < 0)
-		dev_err(&dsi->dev,
-			"Failed to detach from DSI0 host: %d\n", ret);
+		dev_err(&dsi->dev, "failed to detach from DSI0 host: %d\n", ret);
 
-	if (pinfo->dsi[1]) {
+	if (pinfo->desc->is_dual_dsi) {
 		ret = mipi_dsi_detach(pinfo->dsi[1]);
 		if (ret < 0)
-			dev_err(&dsi->dev,
-				"Failed to detach from DSI1 host: %d\n", ret);
+			dev_err(&pinfo->dsi[1]->dev, "failed to detach from DSI1 host: %d\n", ret);
 		mipi_dsi_device_unregister(pinfo->dsi[1]);
 	}
 
 	drm_panel_remove(&pinfo->panel);
-
-
 }
 
-static const struct drm_display_mode nt36523_mode = {
-	.clock = (1600 + 200 + 40 + 52) * (2560 + 26 + 4 + 168) * 104 / 1000,
-	.hdisplay = 1600,
-	.hsync_start = 1600 + 200,
-	.hsync_end = 1600 + 200 + 40,
-	.htotal = 1600 + 200 + 40 + 52,
-	.vdisplay = 2560,
-	.vsync_start = 2560 + 26,
-	.vsync_end = 2560 + 26 + 4,
-	.vtotal = 2560 + 26 + 4 + 168,
-};
-
-static const struct panel_desc nt36523_desc = {
-	.modes = &nt36523_mode,
-	.dsi_info = {
-		.type = "NT36523",
-		.channel = 0,
-		.node = NULL,
-	},
-	.width_mm = 1474,
-	.height_mm = 2359,
-	.bpc = 8,
-	.lanes = 3,
-	.format = MIPI_DSI_FMT_RGB888,
-	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM,
-	.is_dual_dsi = true,
-};
-
 static int nt36523_get_modes(struct drm_panel *panel,
 			       struct drm_connector *connector)
 {
 	struct panel_info *pinfo = to_panel_info(panel);
-	const struct drm_display_mode *m = pinfo->desc->modes;
-	struct drm_display_mode *mode;
+	int i;
 
-	mode = drm_mode_duplicate(connector->dev, m);
-	if (!mode) {
-		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
-			m->hdisplay, m->vdisplay, drm_mode_vrefresh(m));
-		return -ENOMEM;
-	}
+	for (i = 0; i < pinfo->desc->num_modes; i++) {
+		const struct drm_display_mode *m = &pinfo->desc->modes[i];
+		struct drm_display_mode *mode;
+
+		mode = drm_mode_duplicate(connector->dev, m);
+		if (!mode) {
+			dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				m->hdisplay, m->vdisplay, drm_mode_vrefresh(m));
+			return -ENOMEM;
+		}
 
-	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
-	drm_mode_set_name(mode);
-	drm_mode_probed_add(connector, mode);
+		mode->type = DRM_MODE_TYPE_DRIVER;
+		if (i == 0)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_set_name(mode);
+		drm_mode_probed_add(connector, mode);
+	}
 
 	connector->display_info.width_mm = pinfo->desc->width_mm;
 	connector->display_info.height_mm = pinfo->desc->height_mm;
 	connector->display_info.bpc = pinfo->desc->bpc;
 
-	return 1;
+	return pinfo->desc->num_modes;
+}
+
+static enum drm_panel_orientation nt36523_get_orientation(struct drm_panel *panel)
+{
+	struct panel_info *pinfo = to_panel_info(panel);
+
+	return pinfo->orientation;
 }
 
 static const struct drm_panel_funcs nt36523_panel_funcs = {
+	.disable = nt36523_disable,
 	.prepare = nt36523_prepare,
 	.unprepare = nt36523_unprepare,
 	.get_modes = nt36523_get_modes,
+	.get_orientation = nt36523_get_orientation,
 };
 
+static int nt36523_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness_large(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static int nt36523_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness_large(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness;
+}
+
+static const struct backlight_ops nt36523_bl_ops = {
+	.update_status = nt36523_bl_update_status,
+	.get_brightness = nt36523_bl_get_brightness,
+};
+
+static struct backlight_device *nt36523_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 512,
+		.max_brightness = 4095,
+		.scale = BACKLIGHT_SCALE_NON_LINEAR,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &nt36523_bl_ops, &props);
+}
+
 static int nt36523_probe(struct mipi_dsi_device *dsi)
 {
 	struct device *dev = &dsi->dev;
-	struct device_node *dsi_r;
-	struct mipi_dsi_host *dsi_r_host;
+	struct device_node *dsi1;
+	struct mipi_dsi_host *dsi1_host;
 	struct panel_info *pinfo;
 	const struct mipi_dsi_device_info *info;
-	int i, dsi_count = 1, ret;
+	int i, ret;
 
 	pinfo = devm_kzalloc(dev, sizeof(*pinfo), GFP_KERNEL);
 	if (!pinfo)
 		return -ENOMEM;
 
-	for (i = 0; i < ARRAY_SIZE(pinfo->supplies); i++)
-		pinfo->supplies[i].supply = nt36523_regulator_names[i];
-
-	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(pinfo->supplies),
-				      pinfo->supplies);
-	if (ret < 0)
-		return dev_err_probe(dev, ret, "failed to get regulators\n");
+	pinfo->vddio = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(pinfo->vddio))
+		return dev_err_probe(dev, PTR_ERR(pinfo->vddio), "failed to get vddio regulator\n");
 
-	for (i = 0; i < ARRAY_SIZE(pinfo->supplies); i++) {
-		ret = regulator_set_load(pinfo->supplies[i].consumer,
-					 nt36523_regulator_enable_loads[i]);
-		if (ret)
-			return dev_err_probe(dev, ret, "failed to set regulator enable loads\n");
-	}
+	pinfo->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(pinfo->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(pinfo->reset_gpio), "failed to get reset gpio\n");
 
 	pinfo->desc = of_device_get_match_data(dev);
 	if (!pinfo->desc)
 		return -ENODEV;
 
-	pinfo->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(pinfo->reset_gpio)) {
-		return dev_err_probe(dev, PTR_ERR(pinfo->reset_gpio),
-				     "Failed to get reset gpio\n");
-	}
-
-	/* If the panel is connected on two DSIs then DSI0 left, DSI1 right */
+	/* If the panel is dual dsi, register DSI1 */
 	if (pinfo->desc->is_dual_dsi) {
 		info = &pinfo->desc->dsi_info;
-		dsi_r = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);
-		if (!dsi_r) {
-			dev_err(dev, "Cannot get secondary DSI node.\n");
+
+		dsi1 = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);
+		if (!dsi1) {
+			dev_err(dev, "cannot get secondary DSI node.\n");
 			return -ENODEV;
 		}
-		dsi_r_host = of_find_mipi_dsi_host_by_node(dsi_r);
-		of_node_put(dsi_r);
-		if (!dsi_r_host) {
-			dev_err(dev, "Cannot get secondary DSI host\n");
-			return -EPROBE_DEFER;
-		}
 
-		pinfo->dsi[1] = mipi_dsi_device_register_full(dsi_r_host, info);
+		dsi1_host = of_find_mipi_dsi_host_by_node(dsi1);
+		of_node_put(dsi1);
+		if (!dsi1_host)
+			return dev_err_probe(dev, -EPROBE_DEFER, "cannot get secondary DSI host\n");
+
+		pinfo->dsi[1] = mipi_dsi_device_register_full(dsi1_host, info);
 		if (!pinfo->dsi[1]) {
-			dev_err(dev, "Cannot get secondary DSI node\n");
+			dev_err(dev, "cannot get secondary DSI device\n");
 			return -ENODEV;
 		}
-		dsi_count++;
 	}
 
 	pinfo->dsi[0] = dsi;
 	mipi_dsi_set_drvdata(dsi, pinfo);
+	drm_panel_init(&pinfo->panel, dev, &nt36523_panel_funcs, DRM_MODE_CONNECTOR_DSI);
 
-	drm_panel_init(&pinfo->panel, dev, &nt36523_panel_funcs,
-		       DRM_MODE_CONNECTOR_DSI);
+	ret = of_drm_get_panel_orientation(dev->of_node, &pinfo->orientation);
+	if (ret < 0) {
+		dev_err(dev, "%pOF: failed to get orientation %d\n", dev->of_node, ret);
+		return ret;
+	}
 
-	ret = drm_panel_of_backlight(&pinfo->panel);
-	if (ret)
-		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+	if (pinfo->desc->has_dcs_backlight) {
+		pinfo->panel.backlight = nt36523_create_backlight(dsi);
+		if (IS_ERR(pinfo->panel.backlight))
+			return dev_err_probe(dev, PTR_ERR(pinfo->panel.backlight),
+					     "Failed to create backlight\n");
+	} else {
+		ret = drm_panel_of_backlight(&pinfo->panel);
+		if (ret)
+			return dev_err_probe(dev, ret, "Failed to get backlight\n");
+	}
 
 	drm_panel_add(&pinfo->panel);
 
-	for (i = 0; i < dsi_count; i++) {
+	for (i = 0; i < DSI_NUM_MIN + pinfo->desc->is_dual_dsi; i++) {
 		pinfo->dsi[i]->lanes = pinfo->desc->lanes;
 		pinfo->dsi[i]->format = pinfo->desc->format;
 		pinfo->dsi[i]->mode_flags = pinfo->desc->mode_flags;
 
 		ret = mipi_dsi_attach(pinfo->dsi[i]);
-		if (ret < 0) {
-			return dev_err_probe(dev, ret,
-					     "Cannot attach to DSI%d host.\n", i);
-		}
+		if (ret < 0)
+			return dev_err_probe(dev, ret, "cannot attach to DSI%d host.\n", i);
 	}
 
 	return 0;
 }
 
 static const struct of_device_id nt36523_of_match[] = {
-	{ .compatible = "novatek,nt36523", .data = &nt36523_desc },
-	{}
+	{
+		.compatible = "lenovo,j606f-boe-nt36523w",
+		.data = &j606f_boe_desc,
+	},
+	{
+		.compatible = "xiaomi,elish-boe-nt36523",
+		.data = &elish_boe_desc,
+	},
+	{
+		.compatible = "xiaomi,elish-csot-nt36523",
+		.data = &elish_csot_desc,
+	},
+	{
+		.compatible = "xiaomi,nabu-csot-nt36523",
+		.data = &nabu_csot_desc,
+	},
+	{},
 };
 MODULE_DEVICE_TABLE(of, nt36523_of_match);
 
@@ -614,5 +1572,5 @@ static struct mipi_dsi_driver nt36523_driver = {
 module_mipi_dsi_driver(nt36523_driver);
 
 MODULE_AUTHOR("Jianhua Lu <lujianhua000@gmail.com>");
-MODULE_DESCRIPTION("Novatek NT36523 DriverIC panels driver");
-MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DRM driver for Novatek NT36523 based MIPI DSI panels");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/backlight/ktz8866.c b/drivers/video/backlight/ktz8866.c
index 74a3f8de8..2577a6615 100644
--- a/drivers/video/backlight/ktz8866.c
+++ b/drivers/video/backlight/ktz8866.c
@@ -1,129 +1,195 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Backlight driver for the Kinetic KTZ8866
- * Jianhua Lu <lujianhua000@gmail.com>
+ *
+ * Copyright (C) 2022, 2023 Jianhua Lu <lujianhua000@gmail.com>
  */
 
 #include <linux/backlight.h>
-#include <linux/delay.h>
 #include <linux/err.h>
-#include <linux/gpio.h>
-#include <linux/of.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
-#include <linux/slab.h>
-
-#define KTZ8866_ENABLE_REG           0x08
-#define KTZ8866_BRIGHT_LB_REG        0x04
-#define KTZ8866_BRIGHT_HB_REG        0x05
-
-#define KTZ8866_ON_CMD               0x5F
-#define KTZ8866_OFF_CMD              0x1F
-
-#define KTZ8866_DEF_BRIGHT           1800
-#define KTZ8866_MAX_BRIGHT           2047
-
-/* Helper */
-#define HIGH_BYTE(x)                 (u8)((x >> 3) & 0xFF)
-#define LOW_BYTE(x)                  (u8)(x & 0x7)
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+#define DEFAULT_BRIGHTNESS 1500
+#define MAX_BRIGHTNESS 2047
+#define REG_MAX 0x15
+
+/* reg */
+#define DEVICE_ID 0x01
+#define BL_CFG1 0x02
+#define BL_CFG2 0x03
+#define BL_BRT_LSB 0x04
+#define BL_BRT_MSB 0x05
+#define BL_EN 0x08
+#define LCD_BIAS_CFG1 0x09
+#define LCD_BIAS_CFG2 0x0A
+#define LCD_BIAS_CFG3 0x0B
+#define LCD_BOOST_CFG 0x0C
+#define OUTP_CFG 0x0D
+#define OUTN_CFG 0x0E
+#define FLAG 0x0F
+#define BL_OPTION1 0x10
+#define BL_OPTION2 0x11
+#define PWM2DIG_LSBs 0x12
+#define PWM2DIG_MSBs 0x13
+#define BL_DIMMING 0x14
+#define PWM_RAMP_TIME 0x15
+
+/* definition */
+#define BL_EN_BIT BIT(6)
+#define LCD_BIAS_EN 0x9F
+#define PWM_HYST 0x5
 
 struct ktz8866 {
 	struct i2c_client *client;
-	struct backlight_device *backlight;
-	bool status;
+	struct regmap *regmap;
+	bool led_on;
+	struct gpio_desc *enable_gpio;
+};
+
+static const struct regmap_config ktz8866_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = REG_MAX,
 };
 
-int ktz8866_write(struct ktz8866 *ktz, u8 reg, u8 data)
+static int ktz8866_write(struct ktz8866 *ktz, unsigned int reg,
+			 unsigned int val)
 {
-	return i2c_smbus_write_byte_data(ktz->client, reg, data);
+	return regmap_write(ktz->regmap, reg, val);
 }
 
-static int ktz8866_backlight_update_status(struct backlight_device *backlight)
+static int ktz8866_update_bits(struct ktz8866 *ktz, unsigned int reg,
+			       unsigned int mask, unsigned int val)
 {
-	struct ktz8866 *ktz = bl_get_data(backlight);
-	int brightness = backlight_get_brightness(backlight);
+	return regmap_update_bits(ktz->regmap, reg, mask, val);
+}
+
+static int ktz8866_backlight_update_status(struct backlight_device *backlight_dev)
+{
+	struct ktz8866 *ktz = bl_get_data(backlight_dev);
+	unsigned int brightness = backlight_get_brightness(backlight_dev);
 
-	if (!ktz->status && brightness > 0) {
-		ktz8866_write(ktz, KTZ8866_ENABLE_REG, KTZ8866_ON_CMD);
-		ktz->status = 1;
+	if (!ktz->led_on && brightness > 0) {
+		ktz8866_update_bits(ktz, BL_EN, BL_EN_BIT, BL_EN_BIT);
+		ktz->led_on = true;
 	} else if (brightness == 0) {
-		ktz8866_write(ktz, KTZ8866_ENABLE_REG, KTZ8866_OFF_CMD);
-		ktz->status = 0;
-		msleep(10);
+		ktz8866_update_bits(ktz, BL_EN, BL_EN_BIT, 0);
+		ktz->led_on = false;
 	}
 
 	/* Set brightness */
-	ktz8866_write(ktz, KTZ8866_BRIGHT_HB_REG, HIGH_BYTE(brightness));
-	ktz8866_write(ktz, KTZ8866_BRIGHT_LB_REG, LOW_BYTE(brightness));
+	ktz8866_write(ktz, BL_BRT_LSB, brightness & 0x7);
+	ktz8866_write(ktz, BL_BRT_MSB, (brightness >> 3) & 0xFF);
 
 	return 0;
 }
 
 static const struct backlight_ops ktz8866_backlight_ops = {
-	.options	= BL_CORE_SUSPENDRESUME,
-	.update_status	= ktz8866_backlight_update_status,
+	.options = BL_CORE_SUSPENDRESUME,
+	.update_status = ktz8866_backlight_update_status,
 };
 
+static void ktz8866_init(struct ktz8866 *ktz)
+{
+	unsigned int val = 0;
+
+	if (of_property_read_u32(ktz->client->dev.of_node, "current-num-sinks", &val))
+		ktz8866_write(ktz, BL_EN, BIT(val) - 1);
+	else
+		/* Enable all 6 current sinks if the number of current sinks isn't specified. */
+		ktz8866_write(ktz, BL_EN, BIT(6) - 1);
+
+	if (of_property_read_u32(ktz->client->dev.of_node, "kinetic,current-ramp-delay-ms", &val)) {
+		if (val <= 128)
+			ktz8866_write(ktz, BL_CFG2, BIT(7) | (ilog2(val) << 3) | PWM_HYST);
+		else
+			ktz8866_write(ktz, BL_CFG2, BIT(7) | ((5 + val / 64) << 3) | PWM_HYST);
+	}
+
+	if (of_property_read_u32(ktz->client->dev.of_node, "kinetic,led-enable-ramp-delay-ms", &val)) {
+		if (val == 0)
+			ktz8866_write(ktz, BL_DIMMING, 0);
+		else {
+			unsigned int ramp_off_time = ilog2(val) + 1;
+			unsigned int ramp_on_time = ramp_off_time << 4;
+			ktz8866_write(ktz, BL_DIMMING, ramp_on_time | ramp_off_time);
+		}
+	}
+
+	if (of_property_read_bool(ktz->client->dev.of_node, "kinetic,enable-lcd-bias"))
+		ktz8866_write(ktz, LCD_BIAS_CFG1, LCD_BIAS_EN);
+}
+
 static int ktz8866_probe(struct i2c_client *client,
 			  const struct i2c_device_id *id)
 {
-	struct backlight_device *backlight;
+	struct backlight_device *backlight_dev;
 	struct backlight_properties props;
 	struct ktz8866 *ktz;
-
-	if (!i2c_check_functionality(client->adapter,
-				     I2C_FUNC_SMBUS_BYTE_DATA)) {
-		dev_warn(&client->dev,
-			 "ktz8866 I2C adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");
-		return -EIO;
-	}
+	int ret = 0;
 
 	ktz = devm_kzalloc(&client->dev, sizeof(*ktz), GFP_KERNEL);
 	if (!ktz)
 		return -ENOMEM;
 
 	ktz->client = client;
+	ktz->regmap = devm_regmap_init_i2c(client, &ktz8866_regmap_config);
+	if (IS_ERR(ktz->regmap))
+		return dev_err_probe(&client->dev, PTR_ERR(ktz->regmap), "failed to init regmap\n");
+
+	ret = devm_regulator_get_enable(&client->dev, "vddpos");
+	if (ret)
+		return dev_err_probe(&client->dev, ret, "get regulator vddpos failed\n");
+	ret = devm_regulator_get_enable(&client->dev, "vddneg");
+	if (ret)
+		return dev_err_probe(&client->dev, ret, "get regulator vddneg failed\n");
+
+	ktz->enable_gpio = devm_gpiod_get_optional(&client->dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(ktz->enable_gpio))
+		return PTR_ERR(ktz->enable_gpio);
 
 	memset(&props, 0, sizeof(props));
 	props.type = BACKLIGHT_RAW;
-	props.max_brightness = KTZ8866_MAX_BRIGHT;
-	props.brightness = clamp_t(unsigned int, KTZ8866_DEF_BRIGHT, 0,
-				   props.max_brightness);
-
-	backlight = devm_backlight_device_register(&client->dev, "ktz8866-backlight",
-					      &client->dev, ktz, &ktz8866_backlight_ops,
-					      &props);
-	if (IS_ERR(backlight)) {
-		dev_err(&client->dev, "failed to register backlight\n");
-		return PTR_ERR(backlight);
-	}
+	props.max_brightness = MAX_BRIGHTNESS;
+	props.brightness = DEFAULT_BRIGHTNESS;
+	props.scale = BACKLIGHT_SCALE_LINEAR;
 
-	backlight_update_status(backlight);
+	backlight_dev = devm_backlight_device_register(&client->dev, "ktz8866-backlight",
+					&client->dev, ktz, &ktz8866_backlight_ops, &props);
+	if (IS_ERR(backlight_dev))
+		return dev_err_probe(&client->dev, PTR_ERR(backlight_dev),
+				"failed to register backlight device\n");
 
-	i2c_set_clientdata(client, backlight);
+	ktz8866_init(ktz);
+
+	i2c_set_clientdata(client, backlight_dev);
+	backlight_update_status(backlight_dev);
 
 	return 0;
 }
 
 static void ktz8866_remove(struct i2c_client *client)
 {
-	struct backlight_device *backlight = i2c_get_clientdata(client);
-
-	backlight->props.brightness = 0;
-	backlight_update_status(backlight);
-
-
+	struct backlight_device *backlight_dev = i2c_get_clientdata(client);
+	backlight_dev->props.brightness = 0;
+	backlight_update_status(backlight_dev);
 }
 
 static const struct i2c_device_id ktz8866_ids[] = {
 	{ "ktz8866", 0 },
-	{}
+	{},
 };
 MODULE_DEVICE_TABLE(i2c, ktz8866_ids);
 
 static const struct of_device_id ktz8866_match_table[] = {
-	{ .compatible = "kinetic,ktz8866",},
-	{}
+	{
+		.compatible = "kinetic,ktz8866",
+	},
+	{},
 };
 
 static struct i2c_driver ktz8866_driver = {
@@ -138,6 +204,6 @@ static struct i2c_driver ktz8866_driver = {
 
 module_i2c_driver(ktz8866_driver);
 
-MODULE_AUTHOR("Jianhua Lu <lujianhua000@gmail.com>");
 MODULE_DESCRIPTION("Kinetic KTZ8866 Backlight Driver");
+MODULE_AUTHOR("Jianhua Lu <lujianhua000@gmail.com>");
 MODULE_LICENSE("GPL");
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index 1a921e894..1e582216a 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -302,7 +302,6 @@ int mipi_dsi_dcs_set_display_brightness_large(struct mipi_dsi_device *dsi,
 					     u16 brightness);
 int mipi_dsi_dcs_get_display_brightness_large(struct mipi_dsi_device *dsi,
 					     u16 *brightness);
-
 /**
  * mipi_dsi_dcs_write_seq - transmit a DCS command with payload
  * @dsi: DSI peripheral device
-- 
2.46.1

