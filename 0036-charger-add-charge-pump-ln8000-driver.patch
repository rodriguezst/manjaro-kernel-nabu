From c6ceaa89d306e8544540664f574034dd149ccbc0 Mon Sep 17 00:00:00 2001
From: maverick <maverick_jia@sina.com>
Date: Tue, 30 Jan 2024 14:21:44 +0800
Subject: [PATCH 36/45] charger: add charge pump ln8000 driver

---
 drivers/power/supply/Kconfig          |    7 +
 drivers/power/supply/Makefile         |    1 +
 drivers/power/supply/ln8000_charger.c | 1642 +++++++++++++++++++++++++
 drivers/power/supply/ln8000_charger.h |  320 +++++
 4 files changed, 1970 insertions(+)
 create mode 100644 drivers/power/supply/ln8000_charger.c
 create mode 100644 drivers/power/supply/ln8000_charger.h

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index c14ca6790..27fbcc1e7 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -723,6 +723,13 @@ config CHARGER_BQ256XX
 	  charge management and system power path management devices for single
 	  cell Li-ion and Li-polymer batteries.
 
+config CHARGER_LN8000
+        tristate "LionSemi LN8000 Battery Charger"
+        depends on I2C
+        select REGMAP_I2C
+        help
+          Say Y to enable support for the LN8000 charger on NABU
+
 config CHARGER_RK817
 	tristate "Rockchip RK817 PMIC Battery Charger"
 	depends on MFD_RK808
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 004256271..b57ef468e 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -92,6 +92,7 @@ obj-$(CONFIG_CHARGER_BQ2515X)	+= bq2515x_charger.o
 obj-$(CONFIG_CHARGER_BQ25890)	+= bq25890_charger.o
 obj-$(CONFIG_CHARGER_BQ25980)	+= bq25980_charger.o
 obj-$(CONFIG_CHARGER_BQ256XX)	+= bq256xx_charger.o
+obj-$(CONFIG_CHARGER_LN8000)	+= ln8000_charger.o
 obj-$(CONFIG_CHARGER_RK817)	+= rk817_charger.o
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
diff --git a/drivers/power/supply/ln8000_charger.c b/drivers/power/supply/ln8000_charger.c
new file mode 100644
index 000000000..492b0d4f5
--- /dev/null
+++ b/drivers/power/supply/ln8000_charger.c
@@ -0,0 +1,1642 @@
+/*
+ * ln8000-charger.c - Charger driver for LIONSEMI LN8000
+ *
+ * Copyright (C) 2021 Lion Semiconductor Inc.
+ * Copyright (C) 2021 XiaoMi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_wakeup.h>
+#include <linux/power_supply.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/sysfs.h>
+#include <linux/debugfs.h>
+#include <linux/types.h>
+//#include <linux/power/ln8000_charger.h>
+#include "ln8000_charger.h"
+
+#define ln_err(fmt, ...)				\
+do {									\
+	if (info->dev_role == LN_PRIMARY)   \
+		printk(KERN_ERR "ln8000@pri: %s: " fmt, __func__, ##__VA_ARGS__);   \
+	else																	\
+		printk(KERN_ERR "ln8000@sec: %s: " fmt, __func__, ##__VA_ARGS__);   \
+} while (0);
+
+#define ln_info(fmt, ...)				\
+do {									\
+	if (info->dev_role == LN_PRIMARY)   \
+		printk(KERN_INFO "ln8000@pri: %s: " fmt, __func__, ##__VA_ARGS__);  \
+	else																	\
+		printk(KERN_INFO "ln8000@sec: %s: " fmt, __func__, ##__VA_ARGS__);  \
+} while (0);
+
+#define ln_dbg(fmt, ...)				\
+do {									\
+	if (info->dev_role == LN_PRIMARY)   \
+		printk(KERN_DEBUG "ln8000@pri: %s: " fmt, __func__, ##__VA_ARGS__); \
+	else																	\
+		printk(KERN_DEBUG "ln8000@sec: %s: " fmt, __func__, ##__VA_ARGS__); \
+} while (0);
+
+#define LN8000_REG_PRINT(reg_addr, val)							\
+do {															\
+	ln_info("  --> [%-20s]   0x%02X   :   0x%02X\n",			\
+			#reg_addr, LN8000_REG_##reg_addr, (val) & 0xFF);	\
+} while (0);
+
+#define LN8000_PARSE_PROP(ret, pdata, field, prop, default_prop)		\
+do {																	\
+	if (ret) {														 	\
+		ln_info("%s = %d (set to default)\n", #field, default_prop);	\
+		pdata->field = default_prop;									\
+	} else {															\
+		ln_info("%s = %d\n", #field, prop);								\
+		pdata->field = prop;											\
+	}																  	\
+} while (0);
+
+#define LN8000_BIT_CHECK(val, idx, desc) if(val & (1 << idx)) ln_info("-> %s\n", desc)
+#define LN8000_IS_PRIMARY(info) (info->dev_role == LN_PRIMARY)
+#define LN8000_ROLE(info) (LN8000_IS_PRIMARY(info) ? "prim" : "sec ")
+#define LN8000_USE_GPIO(pdata) ((pdata != NULL) && (pdata->irq_gpio))
+#define LN8000_STATUS(val, mask) ((val & mask) ? true : false)
+
+/**
+ * I2C control functions : when occurred I2C tranfer fault, we 
+ * will retry to it. (default count:3) 
+ */
+#define I2C_RETRY_CNT   3
+static int ln8000_read_reg(struct ln8000_info *info, u8 addr, void *data)
+{
+	int i, ret = 0;
+
+	mutex_lock(&info->i2c_lock);
+	for (i=0; i < I2C_RETRY_CNT; ++i) {
+		ret = regmap_read(info->regmap, addr, data);
+		if (IS_ERR_VALUE((unsigned long)ret)) {
+			ln_info("failed-read, reg(0x%02X), ret(%d)\n", addr, ret);
+		} else {
+			break;
+		}
+	}
+	mutex_unlock(&info->i2c_lock);
+	return ret;
+}
+
+static int ln8000_bulk_read_reg(struct ln8000_info *info, u8 addr, void *data, int count)
+{
+	int i, ret = 0;
+
+	mutex_lock(&info->i2c_lock);
+	for (i=0; i < I2C_RETRY_CNT; ++i) {
+		ret = regmap_bulk_read(info->regmap, addr, data, count);
+		if (IS_ERR_VALUE((unsigned long)ret)) {
+			ln_info("failed-bulk-read, reg(0x%02X, %d bytes), ret(%d)\n", addr, count, ret);
+		} else {
+			break;
+		}
+	}
+	mutex_unlock(&info->i2c_lock);
+	return ret;
+}
+
+static int ln8000_write_reg(struct ln8000_info *info, u8 addr, u8 data)
+{
+	int i, ret = 0;
+
+	mutex_lock(&info->i2c_lock);
+	for (i=0; i < I2C_RETRY_CNT; ++i) {
+		ret = regmap_write(info->regmap, addr, data);
+		if (IS_ERR_VALUE((unsigned long)ret)) {
+			ln_info("failed-write, reg(0x%02X), ret(%d)\n", addr, ret);
+		} else {
+			break;
+		}
+	}
+	mutex_unlock(&info->i2c_lock);
+	return ret;
+}
+
+static int ln8000_update_reg(struct ln8000_info *info, u8 addr, u8 mask, u8 data)
+{
+	int i, ret = 0;
+
+	mutex_lock(&info->i2c_lock);
+	for (i=0; i < I2C_RETRY_CNT; ++i) {
+		ret = regmap_update_bits(info->regmap, addr, mask, data);
+		if (IS_ERR_VALUE((unsigned long)ret)) {
+			ln_info("failed-update, reg(0x%02X), ret(%d)\n", addr, ret);
+		} else {
+			break;
+		}
+	}
+	mutex_unlock(&info->i2c_lock);
+	return ret;
+}
+
+/**
+ * Register control functions 
+ */
+#if 0
+static int ln8000_set_sw_freq(struct ln8000_info *info, unsigned int cfg)
+{
+	return ln8000_update_reg(info, LN8000_REG_SYS_CTRL, 0xF << 4, cfg << 4);
+}
+#endif
+
+static int ln8000_set_vac_ovp(struct ln8000_info *info, unsigned int ovp_th)
+{
+	u8 cfg;
+
+	if (ovp_th <= 6500000) {
+		cfg = LN8000_VAC_OVP_6P5V;
+	} else if (ovp_th <= 11000000) {
+		cfg = LN8000_VAC_OVP_11V;
+	} else if (ovp_th <= 12000000) {
+		cfg = LN8000_VAC_OVP_12V;
+	} else {
+		cfg = LN8000_VAC_OVP_13V;
+	}
+
+	return ln8000_update_reg(info, LN8000_REG_GLITCH_CTRL, 0x3 << 2, cfg << 2);
+}
+
+/* battery float voltage */
+static int ln8000_set_vbat_float(struct ln8000_info *info, unsigned int cfg)
+{
+	u8 val;
+
+	if (cfg < LN8000_VBAT_FLOAT_MIN)
+	   val = 0x00;
+	else if (cfg > LN8000_VBAT_FLOAT_MAX)
+	   val = 0xFF;
+	else
+	   val = (cfg - LN8000_VBAT_FLOAT_MIN) / LN8000_VBAT_FLOAT_LSB;
+
+	return ln8000_write_reg(info, LN8000_REG_V_FLOAT_CTRL, val);
+}
+
+static int ln8000_set_iin_limit(struct ln8000_info *info, unsigned int cfg)
+{
+	u8 val = cfg / LN8000_IIN_CFG_LSB;
+
+	ln_info("iin_limit=%dmA(iin_ctrl=0x%x)\n", cfg / 1000, val);
+
+	return ln8000_update_reg(info, LN8000_REG_IIN_CTRL, 0x7F, val);
+}
+
+static int ln8000_set_ntc_alarm(struct ln8000_info *info, unsigned int cfg)
+{
+	int ret;
+
+	/* update lower bits */
+	ret = ln8000_write_reg(info, LN8000_REG_NTC_CTRL, (cfg & 0xFF));
+	if (ret < 0)
+	   return ret;
+
+	/* update upper bits */
+	ret = ln8000_update_reg(info, LN8000_REG_ADC_CTRL, 0x3, (cfg >> 8));
+	return ret;
+}
+
+/* battery voltage OV protection */
+static int ln8000_enable_vbat_ovp(struct ln8000_info *info, bool enable)
+{
+	u8 val;
+
+	val = (enable) ? 0 : 1;//disable
+	val <<= LN8000_BIT_DISABLE_VBAT_OV;
+
+	return ln8000_update_reg(info, LN8000_REG_FAULT_CTRL, BIT(LN8000_BIT_DISABLE_VBAT_OV), val);
+}
+
+static int ln8000_enable_vbat_regulation(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_DISABLE_VFLOAT_LOOP, 
+							 !(enable) << LN8000_BIT_DISABLE_VFLOAT_LOOP);
+}
+
+static int ln8000_enable_vbat_loop_int(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_ENABLE_VFLOAT_LOOP_INT, 
+							 enable << LN8000_BIT_ENABLE_VFLOAT_LOOP_INT);
+}
+
+/* input current OC protection */
+static int ln8000_enable_iin_ocp(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_FAULT_CTRL, 
+							 0x1 << LN8000_BIT_DISABLE_IIN_OCP, 
+							 !(enable) << LN8000_BIT_DISABLE_IIN_OCP);
+}
+
+static int ln8000_enable_iin_regulation(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_DISABLE_IIN_LOOP, 
+							 !(enable) << LN8000_BIT_DISABLE_IIN_LOOP);
+}
+
+static int ln8000_enable_iin_loop_int(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_ENABLE_IIN_LOOP_INT, 
+							 enable << LN8000_BIT_ENABLE_IIN_LOOP_INT);
+}
+
+static int ln8000_enable_vac_ov(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_FAULT_CTRL, 
+							 0x1 << LN8000_BIT_DISABLE_VAC_OV, 
+							 !(enable) << LN8000_BIT_DISABLE_VAC_OV);
+}
+
+static int ln8000_enable_tdie_prot(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_TEMP_MAX_EN, enable << LN8000_BIT_TEMP_MAX_EN);
+}
+
+static int ln8000_enable_tdie_regulation(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 
+							 0x1 << LN8000_BIT_TEMP_REG_EN, enable << LN8000_BIT_TEMP_REG_EN);
+}
+
+/* ADC channel enable */
+static int ln8000_set_adc_ch(struct ln8000_info *info, unsigned int ch, bool enable)
+{
+	u8 mask;
+	u8 val;
+	int ret;
+
+	if ((ch > LN8000_ADC_CH_ALL) || (ch < 1))
+	   return -EINVAL;
+
+	if (ch == LN8000_ADC_CH_ALL) {
+	   // update all channels
+	   val  = (enable) ? 0x3E : 0x00;
+	   ret  = ln8000_write_reg(info, LN8000_REG_ADC_CFG, val);
+	} else {
+	   // update selected channel
+	   mask = 1<<(ch-1);
+	   val  = (enable) ? 1 : 0;
+	   val <<= (ch-1);
+	   ret  = ln8000_update_reg(info, LN8000_REG_ADC_CFG, mask, val);
+	}
+
+	return ret;
+}
+
+/* BUS temperature monitoring (protection+alarm) */
+static int ln8000_enable_tbus_monitor(struct ln8000_info *info, bool enable)
+{
+	int ret;
+
+	/* enable BUS monitoring */
+	ret = ln8000_update_reg(info, LN8000_REG_RECOVERY_CTRL, 0x1 << 1, enable << 1);
+	if (ret < 0) 
+	   return ret;
+
+	/* enable BUS ADC channel */
+	if (enable) {
+	   ret = ln8000_set_adc_ch(info, LN8000_ADC_CH_TSBUS, true);
+	}
+	return ret;
+}
+
+static int ln8000_enable_vin_uv_track(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_FAULT_CTRL,
+				0x1 << 0, !(enable) << 0);
+}
+
+/* BAT temperature monitoring (protection+alarm) */
+static int ln8000_enable_tbat_monitor(struct ln8000_info *info, bool enable)
+{
+	int ret;
+
+	/* enable BAT monitoring */
+	ret = ln8000_update_reg(info, LN8000_REG_RECOVERY_CTRL, 0x1 << 0, enable << 0);
+	if (ret < 0)
+	   return ret;
+
+	/* enable BAT ADC channel */
+	if (enable) {
+	   ret = ln8000_set_adc_ch(info, LN8000_ADC_CH_TSBAT, true);
+	}
+	return ret;
+}
+
+/* watchdog timer */
+static int ln8000_enable_wdt(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 7, enable << 7);
+}
+
+#if 0
+static int ln8000_set_wdt(struct ln8000_info *info, unsigned int cfg)
+{
+	if (cfg >= LN8000_WATCHDOG_MAX) {
+		cfg = LN8000_WATCHDOG_40SEC;
+	}
+
+	return ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x3 << 5, cfg << 5);
+}
+#endif
+
+/* unplug / reverse-current detection */
+static int ln8000_enable_rcp(struct ln8000_info *info, bool enable)
+{
+	info->rcp_en = enable;
+
+	return ln8000_update_reg(info, LN8000_REG_SYS_CTRL, 
+							 BIT(LN8000_BIT_REV_IIN_DET), 
+							 enable << LN8000_BIT_REV_IIN_DET);
+}
+
+/* auto-recovery */
+static int ln8000_enable_auto_recovery(struct ln8000_info *info, bool enable)
+{
+	return ln8000_update_reg(info, LN8000_REG_RECOVERY_CTRL, 0xF << 4, ((0xF << 4) * enable));
+}
+
+static int ln8000_set_adc_mode(struct ln8000_info *info, unsigned int cfg)
+{
+	return ln8000_update_reg(info, LN8000_REG_ADC_CTRL, 0x7 << 5, cfg << 5);
+}
+
+static int ln8000_set_adc_hib_delay(struct ln8000_info *info, unsigned int cfg)
+{
+	return ln8000_update_reg(info, LN8000_REG_ADC_CTRL, 0x3 << 3, cfg << 3);
+}
+
+/* grab programmed battery float voltage (uV) */
+static int ln8000_get_vbat_float(struct ln8000_info *info)
+{
+	int ret, val;
+
+	ret = ln8000_read_reg(info, LN8000_REG_V_FLOAT_CTRL, &val);
+	if (ret < 0)
+	   return ret;
+
+	return ((val & 0xff) * LN8000_VBAT_FLOAT_LSB  + LN8000_VBAT_FLOAT_MIN);//uV
+}
+
+/* grab programmed input current limit (uA) */
+static int ln8000_get_iin_limit(struct ln8000_info *info)
+{
+	int ret, val;
+	int iin;
+
+	ret = ln8000_read_reg(info, LN8000_REG_IIN_CTRL, &val);
+	if (ret < 0)
+		return ret;
+
+	iin = ((val & 0x7f) * LN8000_IIN_CFG_LSB);
+
+	if (iin < LN8000_IIN_CFG_MIN) {
+		iin = LN8000_IIN_CFG_MIN;
+	}
+
+	return iin;
+}
+
+/* enable/disable STANDBY */
+static inline void ln8000_sw_standby(struct ln8000_info *info, bool standby)
+{
+	u8 val = (standby) ? BIT(LN8000_BIT_STANDBY_EN) : 0x00;
+	ln8000_update_reg(info, LN8000_REG_SYS_CTRL, BIT(LN8000_BIT_STANDBY_EN), val);
+}
+
+/* Convert Raw ADC Code */
+static void ln8000_convert_adc_code(struct ln8000_info *info, unsigned int ch, u8 *sts, int *result)
+{
+	int adc_raw;	// raw ADC value
+	int adc_final;	// final (converted) ADC value
+
+	switch (ch) {
+	  case LN8000_ADC_CH_VOUT:
+		adc_raw   = ((sts[1] & 0xFF)<<2) | ((sts[0] & 0xC0)>>6);
+		adc_final = adc_raw * LN8000_ADC_VOUT_STEP;//uV
+		break;
+	  case LN8000_ADC_CH_VIN:
+		adc_raw   = ((sts[1] & 0x3F)<<4) | ((sts[0] & 0xF0)>>4);
+		adc_final = adc_raw * LN8000_ADC_VIN_STEP;//uV
+		break;
+	  case LN8000_ADC_CH_VBAT:
+		adc_raw   = ((sts[1] & 0x03)<<8) | (sts[0] & 0xFF);
+		adc_final = adc_raw * LN8000_ADC_VBAT_STEP;//uV
+		break;
+	  case LN8000_ADC_CH_VAC:
+		adc_raw   = (((sts[1] & 0x0F)<<6) | ((sts[0] & 0xFC)>>2)) + LN8000_ADC_VAC_OS;
+		adc_final = adc_raw * LN8000_ADC_VAC_STEP;//uV
+		break;
+	  case LN8000_ADC_CH_IIN:
+		adc_raw   = ((sts[1] & 0x03)<<8) | (sts[0] & 0xFF);
+		adc_final = adc_raw * LN8000_ADC_IIN_STEP;//uA
+		break;
+	  case LN8000_ADC_CH_DIETEMP:
+		adc_raw   = ((sts[1] & 0x0F)<<6) | ((sts[0] & 0xFC)>>2);
+		adc_final = (935 - adc_raw) * LN8000_ADC_DIETEMP_STEP / LN8000_ADC_DIETEMP_DENOM;//dC
+		if (adc_final > LN8000_ADC_DIETEMP_MAX)
+		   adc_final = LN8000_ADC_DIETEMP_MAX;
+		else if (adc_final < LN8000_ADC_DIETEMP_MIN)
+		   adc_final = LN8000_ADC_DIETEMP_MIN;
+		break;
+	  case LN8000_ADC_CH_TSBAT:
+		adc_raw   = ((sts[1] & 0x3F)<<4) | ((sts[0] & 0xF0)>>4);
+		adc_final = adc_raw * LN8000_ADC_NTCV_STEP;//(NTC) uV
+		break;
+	  case LN8000_ADC_CH_TSBUS:
+		adc_raw   = ((sts[1] & 0xFF)<<2) | ((sts[0] & 0xC0)>>6);
+		adc_final = adc_raw * LN8000_ADC_NTCV_STEP;//(NTC) uV
+		break;
+	  default:
+		adc_raw   = -EINVAL;
+		adc_final = -EINVAL;
+		break;
+	}
+
+	*result = adc_final;
+	return;
+}
+
+static void ln8000_print_regmap(struct ln8000_info *info)
+{
+#if 0
+	const u8 print_reg_num = (LN8000_REG_CHARGE_CTRL - LN8000_REG_INT1_MSK) + 1;
+	u32 regs[64] = {0x0, };
+	char temp_buf[128] = {0,};
+	int i, ret;
+
+	for (i = 0; i < print_reg_num; ++i) {
+		ret = ln8000_read_reg(info, LN8000_REG_INT1_MSK + i, &regs[i]);
+		if (IS_ERR_VALUE((unsigned long)ret)) {
+			ln_err("fail to read reg for print_regmap[%d]\n", i);
+			regs[i] = 0xFF;
+		}
+		sprintf(temp_buf + strlen(temp_buf), "0x%02X[0x%02X],", LN8000_REG_INT1_MSK + i, regs[i]);
+		if (((i+1) % 10 == 0) || ((i+1) == print_reg_num)) {
+			ln_info("%s\n", temp_buf);
+			memset(temp_buf, 0x0, sizeof(temp_buf));
+		}
+	}
+#endif
+}
+
+/**
+ * LN8000 device driver control routines 
+ */
+static int ln8000_check_status(struct ln8000_info *info)
+{
+	u8 val[4];
+
+	if (ln8000_bulk_read_reg(info, LN8000_REG_SYS_STS, val, 4) < 0) {
+		return -EINVAL;
+	}
+
+	mutex_lock(&info->data_lock);
+
+	info->vbat_regulated  = LN8000_STATUS(val[0], LN8000_MASK_VFLOAT_LOOP_STS);
+	info->iin_regulated   = LN8000_STATUS(val[0], LN8000_MASK_IIN_LOOP_STS);
+	info->pwr_status	  = val[0] & (LN8000_MASK_BYPASS_ENABLED | LN8000_MASK_SWITCHING_ENABLED | \
+									  LN8000_MASK_STANDBY_STS | LN8000_MASK_SHUTDOWN_STS);
+	info->tdie_fault	  = LN8000_STATUS(val[1], LN8000_MASK_TEMP_MAX_STS);
+	info->tdie_alarm	  = LN8000_STATUS(val[1], LN8000_MASK_TEMP_REGULATION_STS);
+	if (!info->pdata->tbat_mon_disable || !info->pdata->tbus_mon_disable) {
+		info->tbus_tbat_fault = LN8000_STATUS(val[1], LN8000_MASK_NTC_SHUTDOWN_STS); //tbus or tbat
+		info->tbus_tbat_alarm = LN8000_STATUS(val[1], LN8000_MASK_NTC_ALARM_STS);//tbus or tbat
+	}
+	info->iin_rc		  = LN8000_STATUS(val[1], LN8000_MASK_REV_IIN_STS);
+
+	info->wdt_fault  = LN8000_STATUS(val[2], LN8000_MASK_WATCHDOG_TIMER_STS);
+	info->vbat_ov	= LN8000_STATUS(val[2], LN8000_MASK_VBAT_OV_STS);
+	info->vac_unplug = LN8000_STATUS(val[2], LN8000_MASK_VAC_UNPLUG_STS);
+	info->vac_ov	 = LN8000_STATUS(val[2], LN8000_MASK_VAC_OV_STS);
+	info->vbus_ov	= LN8000_STATUS(val[2], LN8000_MASK_VIN_OV_STS);
+	info->volt_qual  = !(LN8000_STATUS(val[2], 0x7F));
+	if (info->volt_qual == 1 && info->chg_en == 1) {
+		info->volt_qual = !(LN8000_STATUS(val[3], 1 << 5));
+		if (info->volt_qual == 0) {
+			ln_info("volt_fault_detected (volt_qual=%d)\n", info->volt_qual);
+		/* clear latched status */
+		ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 2, 0x1 << 2);
+		ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 2, 0x0 << 2);
+		}
+	}
+	info->iin_oc	 = LN8000_STATUS(val[3], LN8000_MASK_IIN_OC_DETECTED);
+
+	mutex_unlock(&info->data_lock);
+
+	return 0;
+}
+
+static void ln8000_irq_sleep(struct ln8000_info *info, int suspend)
+{
+	if (info->client->irq <= 0)
+	   return;
+
+	if (suspend) {
+	   ln_info("disable/suspend IRQ\n");
+	   disable_irq(info->client->irq);
+	} else {
+	   ln_info("enable/resume IRQ\n");
+	   enable_irq(info->client->irq);
+	}
+}
+
+static void ln8000_soft_reset(struct ln8000_info *info)
+{
+	ln8000_write_reg(info, LN8000_REG_LION_CTRL, 0xC6);
+
+	ln8000_irq_sleep(info, 1);
+
+	ln_info("(%s) Trigger soft-reset\n", LN8000_ROLE(info));
+	ln8000_update_reg(info, LN8000_REG_BC_OP_2, 0x1 << 0, 0x1 << 0);
+	msleep(5 * 2);  /* ln8000 min wait time 5ms (after POR) */
+
+	ln8000_irq_sleep(info, 0);
+}
+
+static void ln8000_update_opmode(struct ln8000_info *info)
+{
+	unsigned int op_mode;
+	u32 val;
+
+	/* chack mode status */
+	ln8000_read_reg(info, LN8000_REG_SYS_STS, &val);
+
+	if (val & LN8000_MASK_SHUTDOWN_STS) {
+		op_mode = LN8000_OPMODE_STANDBY;
+	} else if (val & LN8000_MASK_STANDBY_STS) {
+		op_mode = LN8000_OPMODE_STANDBY;
+	} else if (val & LN8000_MASK_SWITCHING_ENABLED) {
+		op_mode = LN8000_OPMODE_SWITCHING;
+	} else if (val & LN8000_MASK_BYPASS_ENABLED) {
+		op_mode = LN8000_OPMODE_BYPASS;
+	} else {
+		op_mode = LN8000_OPMODE_UNKNOWN;
+	}
+
+	if (info->op_mode == LN8000_OPMODE_BYPASS) {
+	    /* recovery(enable) VIN_UV_TRACK default */
+	    ln8000_enable_vin_uv_track(info, 1);
+	}
+
+	if (op_mode != info->op_mode) {
+		/* IC already has been entered standby_mode, need to trigger standbt_en bit */
+		if (op_mode == LN8000_OPMODE_STANDBY) {
+			ln8000_update_reg(info, LN8000_REG_SYS_CTRL, 1 << LN8000_BIT_STANDBY_EN, 1 << LN8000_BIT_STANDBY_EN);
+			ln_info("forced trigger standby_en\n");
+			info->chg_en = 0;
+		}
+		ln_info("op_mode has been changed [%d]->[%d] (sys_st=0x%x)\n", info->op_mode, op_mode, val);
+		info->op_mode = op_mode;
+	}
+
+	return;
+}
+
+static int ln8000_change_opmode(struct ln8000_info *info, unsigned int target_mode)
+{
+	int ret = 0;
+	u8 val, msk = (0x1 << LN8000_BIT_STANDBY_EN | 0x1 << LN8000_BIT_EN_1TO1);
+
+    /* clear latched status */
+    ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 2, 0x1 << 2);
+    ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 2, 0x0 << 2);
+
+	switch(target_mode) {
+	  case LN8000_OPMODE_STANDBY:
+		val = 1 << LN8000_BIT_STANDBY_EN;
+		break;
+	  case LN8000_OPMODE_BYPASS:
+	    /* temp disable VIN_UV_TRACK during on start-up BYPASS mode */
+        ln8000_enable_vin_uv_track(info, 0);
+		val = (0 << LN8000_BIT_STANDBY_EN) | (1 << LN8000_BIT_EN_1TO1);
+		break;
+	  case LN8000_OPMODE_SWITCHING:
+		val = (0 << LN8000_BIT_STANDBY_EN) | (0 << LN8000_BIT_EN_1TO1);
+		break;
+	default:
+		ln_err("invalid index (target_mode=%d)\n", target_mode);
+		return -EINVAL;
+	}
+
+	ret = ln8000_update_reg(info, LN8000_REG_SYS_CTRL, msk, val);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		return -EINVAL;
+	}
+	ln_info("changed opmode [%d] -> [%d]\n", info->op_mode, target_mode);
+	info->op_mode = target_mode;
+
+	return 0;
+}
+
+static int ln8000_init_device(struct ln8000_info *info)
+{
+	unsigned int vbat_float;
+
+	/* config default charging paramter by dt */
+	vbat_float = info->pdata->bat_ovp_th * 100 / 102;   /* ovp thershold = v_float x 1.02 */
+	vbat_float = (vbat_float /1000) * 1000;
+	ln_info("bat_ovp_th=%d, vbat_float=%d\n", info->pdata->bat_ovp_th, vbat_float);
+	ln8000_set_vbat_float(info, vbat_float);
+	info->vbat_ovp_alarm_th = info->pdata->bat_ovp_alarm_th;
+	ln8000_set_vac_ovp(info, info->pdata->bus_ovp_th);
+	info->vin_ovp_alarm_th = info->pdata->bus_ovp_alarm_th;
+	ln8000_set_iin_limit(info, info->pdata->bus_ocp_th - 700000);
+	info->iin_ocp_alarm_th = info->pdata->bus_ocp_alarm_th;
+	ln8000_set_ntc_alarm(info, info->pdata->ntc_alarm_cfg);
+
+	ln8000_update_reg(info, LN8000_REG_REGULATION_CTRL, 0x3 << 2, LN8000_NTC_SHUTDOWN_CFG);
+	ln8000_enable_auto_recovery(info, 0);
+
+	/* config charging protection */
+	ln8000_enable_vbat_ovp(info, !info->pdata->vbat_ovp_disable);
+	ln8000_enable_vbat_regulation(info, !info->pdata->vbat_reg_disable);
+	ln8000_enable_vbat_loop_int(info, !info->pdata->vbat_reg_disable);
+	ln8000_enable_iin_ocp(info, !info->pdata->iin_ocp_disable);
+	ln8000_enable_iin_regulation(info, !info->pdata->iin_reg_disable);
+	ln8000_enable_iin_loop_int(info, !info->pdata->iin_reg_disable);
+	ln8000_enable_tdie_regulation(info, !info->pdata->tdie_reg_disable);
+	ln8000_enable_tdie_prot(info, !info->pdata->tdie_prot_disable);
+	ln8000_enable_rcp(info, 1);
+	ln8000_change_opmode(info, LN8000_OPMODE_STANDBY);
+	ln8000_enable_vac_ov(info, 1);
+
+	/* wdt : disable, adc : shutdown mode */
+	ln8000_enable_wdt(info, false);
+	ln8000_set_adc_mode(info, ADC_SHUTDOWN_MODE);//disable before updating
+	ln8000_set_adc_hib_delay(info, ADC_HIBERNATE_4S);
+	ln8000_set_adc_ch(info, LN8000_ADC_CH_ALL, true);
+	ln8000_enable_tbus_monitor(info, !info->pdata->tbus_mon_disable);//+enables ADC ch
+	ln8000_enable_tbat_monitor(info, !info->pdata->tbat_mon_disable);//+enables ADC ch
+	ln8000_set_adc_mode(info, ADC_AUTO_HIB_MODE);
+
+	/* mark sw initialized (used CHARGE_CTRL bit:7) */
+	ln8000_update_reg(info, LN8000_REG_CHARGE_CTRL, 0x1 << 7, 0x1 << 7);
+	ln8000_write_reg(info, LN8000_REG_THRESHOLD_CTRL, 0x02);
+
+	/* backup to initial setting for comparing to reset value. */
+	ln8000_read_reg(info, LN8000_REG_REGULATION_CTRL, &info->regulation_ctrl);
+	ln8000_read_reg(info, LN8000_REG_ADC_CTRL, &info->adc_ctrl);
+	ln8000_read_reg(info, LN8000_REG_V_FLOAT_CTRL, &info->v_float_ctrl);
+	ln8000_read_reg(info, LN8000_REG_CHARGE_CTRL, &info->charge_ctrl);
+
+	ln8000_print_regmap(info);
+
+	ln_info(" done.\n");
+
+	return 0;
+}
+
+/**
+ * Support power_supply platform for charger block. 
+ * propertis are compatible by Xiaomi platform
+ */
+static int ln8000_get_adc_data(struct ln8000_info *info, unsigned int ch, int *result)
+{
+	int ret;
+	u8 sts[2];
+
+	/* pause adc update */
+	ret  = ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 1, 0x1 << 1);
+	if (ret < 0) {
+	   ln_err("fail to update bit PAUSE_ADC_UPDATE:1 (ret=%d)\n", ret);
+	   return ret;
+	}
+
+	switch (ch) {
+	case LN8000_ADC_CH_VOUT:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC04_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_VIN:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC03_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_VBAT:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC06_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_VAC:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC02_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_IIN:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC01_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_DIETEMP:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC07_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_TSBAT:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC08_STS, sts, 2);
+		break;
+	case LN8000_ADC_CH_TSBUS:
+		ret = ln8000_bulk_read_reg(info, LN8000_REG_ADC09_STS, sts, 2);
+		break;
+	default:
+		ln_err("invalid ch(%d)\n", ch);
+		ret = -EINVAL;
+		break;
+	}
+
+	/* resume adc update */
+	ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1 << 1, 0x0 << 1);
+
+	if (IS_ERR_VALUE((unsigned long)ret) == false) {
+		ln8000_convert_adc_code(info, ch, sts, result);
+	}
+
+	return ret;
+}
+
+static int psy_chg_get_charging_enabled(struct ln8000_info *info)
+{
+	int enabled = 0;	/* disabled */
+
+	ln8000_update_opmode(info);
+	if (info->op_mode >= LN8000_OPMODE_BYPASS) {
+		enabled = 1;
+	}
+
+	return enabled;
+}
+
+static int ln8000_check_regmap_data(struct ln8000_info *info)
+{
+	u32 regulation_ctrl;
+	u32 adc_ctrl;
+	u32 v_float_ctrl;
+	u32 charge_ctrl;
+
+	ln8000_read_reg(info, LN8000_REG_REGULATION_CTRL, &regulation_ctrl);
+	ln8000_read_reg(info, LN8000_REG_ADC_CTRL, &adc_ctrl);
+	ln8000_read_reg(info, LN8000_REG_V_FLOAT_CTRL, &v_float_ctrl);
+	ln8000_read_reg(info, LN8000_REG_CHARGE_CTRL, &charge_ctrl);
+
+	if ((info->regulation_ctrl != regulation_ctrl) ||
+			(info->adc_ctrl != adc_ctrl) ||
+			(info->charge_ctrl != charge_ctrl) ||
+			(info->v_float_ctrl != v_float_ctrl)) {
+		/* Decide register map was reset */
+		ln_err("decided register map RESET, re-initialize device\n");
+		ln_err("regulation_ctrl = 0x%x : 0x%x\n",
+				info->regulation_ctrl, regulation_ctrl);
+		ln_err("adc_ctrl        = 0x%x : 0x%x\n", info->adc_ctrl, adc_ctrl);
+		ln_err("charge_ctrl     = 0x%x : 0x%x\n",
+				info->charge_ctrl, charge_ctrl);
+		ln_err("vbat_float      = 0x%x : 0x%x\n", info->v_float_ctrl, v_float_ctrl);
+		ln8000_init_device(info);
+		msleep(300);
+	}
+
+	return 0;
+}
+static int ln8000_charger_get_property(struct power_supply *psy,
+									   enum power_supply_property prop,
+									   union power_supply_propval *val)
+{
+	struct ln8000_info *info = power_supply_get_drvdata(psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		ln8000_get_adc_data(info, LN8000_ADC_CH_VBAT, &info->vbat_uV);
+		if (info->vbat_uV > LN8000_ADC_VBAT_MIN) {
+			val->intval = 1;	/* detected battery */
+		} else {
+			val->intval = 0;	/* non-detected battery */
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		ln8000_check_status(info);
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		info->chg_en = psy_chg_get_charging_enabled(info);
+
+		if (info->chg_en)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (info->iin_rc)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else if (!info->chg_en)
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ln8000_check_status(info);
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+
+		if (info->tbus_tbat_fault)
+			val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+		else if (info->vbus_ov)
+			val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		else if (info->iin_oc)
+			val->intval = POWER_SUPPLY_HEALTH_OVERCURRENT;
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		val->intval = ln8000_get_vbat_float(info);
+		break;
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		val->intval = ln8000_get_iin_limit(info);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ln8000_get_adc_data(info, LN8000_ADC_CH_VIN, &info->vbus_uV);
+		val->intval = info->vbus_uV / 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		ln8000_get_adc_data(info, LN8000_ADC_CH_IIN, &info->iin_uA);
+		val->intval = info->iin_uA / 1000;
+		break;
+#if 0		//always true, so delete it
+	case POWER_SUPPLY_PROP_ONLINE:
+		ln8000_check_status(info);
+		val->intval = !(info->vac_unplug);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = "ln8000";
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int psy_chg_set_charging_enable(struct ln8000_info *info, int val)
+{
+	int op_mode;
+
+	/* skip duplicate command of charging enable */
+	ln_info("val:%d,chg_en:%d\n",val,info->chg_en);
+	if (val == info->chg_en) {
+		return 0;
+	}
+
+	if (val) {
+		ln8000_check_regmap_data(info);
+		ln_info("start charging\n");
+		op_mode = LN8000_OPMODE_SWITCHING;
+		/* when the start-up to charging, we need to disabled rcp. */
+		ln8000_enable_rcp(info, 0);
+	} else {
+		ln_info("stop charging\n");
+		op_mode = LN8000_OPMODE_STANDBY;
+		ln8000_enable_rcp(info, 1);
+	}
+	info->chg_en = val;
+
+	/* when the start-up to charging, we need to disabled rcp. */
+	ln8000_enable_rcp(info, 0);
+
+	ln8000_change_opmode(info, op_mode);
+	msleep(10);
+	ln8000_update_opmode(info);
+
+	ln8000_print_regmap(info);
+
+	ln_info("op_mode=%d\n", info->op_mode);
+
+	return 0;
+}
+#if 0
+static int ln8000_set_chgmode(struct ln8000_info *info, int mode)
+{
+	int op_mode;
+
+	if (mode == 1) {
+		ln_info("start bypass charging\n");
+		op_mode = LN8000_OPMODE_BYPASS;
+	} else if (mode == 0){
+		ln_info("start switch charging\n");
+		op_mode = LN8000_OPMODE_SWITCHING;
+	}else {
+		ln_info("stop bypass charging\n");
+		op_mode = LN8000_OPMODE_STANDBY;
+	}
+
+
+	ln8000_enable_rcp(info, 0);
+
+	ln8000_change_opmode(info,op_mode);
+	msleep(10);
+	ln8000_update_opmode(info);
+
+	ln8000_print_regmap(info);
+
+	if (mode != 1) {
+		ln8000_set_vac_ovp(info, info->pdata->bus_ovp_th);
+	}
+
+	ln_info("op_mode=%d\n", info->op_mode);
+
+	return 0;
+}
+#endif
+static int ln8000_charger_set_property(struct power_supply *psy,
+									   enum power_supply_property prop,
+									   const union power_supply_propval *val)
+{
+	struct ln8000_info *info = power_supply_get_drvdata(psy);
+	int ret = 0;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = ln8000_set_vbat_float(info, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		ret = ln8000_set_iin_limit(info, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		ret = psy_chg_set_charging_enable(info, val->intval);
+//		ret = ln8000_set_chgmode(info, val->intval);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ln8000_charger_is_writeable(struct power_supply *psy,
+						enum power_supply_property prop) {
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+	case POWER_SUPPLY_PROP_STATUS:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static enum power_supply_property ln8000_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+//	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+};
+
+static int ln8000_get_battery_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct ln8000_info *info = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		ln8000_check_status(info);
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+	
+		/* BAT ocp fault status not suppport */
+		if (info->tbus_tbat_fault)
+			val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+		else if (info->vbat_ov)
+			val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        ln8000_get_adc_data(info, LN8000_ADC_CH_VBAT, &info->vbat_uV);
+        val->intval = info->vbat_uV/1000;
+        break;
+
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		/* ln8000 not support IBAT_ADC */
+        ln8000_get_adc_data(info, LN8000_ADC_CH_IIN, &info->iin_uA);
+        val->intval = (info->iin_uA * 2) / 1000;         /* return to IBUS_ADC x 2 */
+        break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property ln8000_battery_props[] = {
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static int read_reg(void *data, u64 *val)
+{
+	struct ln8000_info *info = data;
+	int ret;
+	u32 temp;
+
+	ret = ln8000_read_reg(info, info->debug_address, &temp);
+	if (ret) {
+	   ln_err("Unable to read reg(0x%02X), ret=%d\n", info->debug_address, ret);
+	   return -EAGAIN;
+	}
+	*val = (u64)temp;
+	return 0;
+}
+
+static int write_reg(void *data, u64 val)
+{
+	struct ln8000_info *info = data;
+	int ret;
+	u8 temp = (u8) val;
+
+	ret = ln8000_write_reg(info, info->debug_address, temp);
+	if (ret) {
+	   ln_err("Unable to write reg(0x%02X), data(0x%02X), ret=%d\n",
+		info->debug_address, temp, ret);
+	   return -EAGAIN;
+	}
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(register_debug_ops, read_reg, write_reg, "0x%02llX\n");
+
+static int ln8000_create_debugfs_entries(struct ln8000_info *info)
+{
+	info->debug_root = debugfs_create_dir((LN8000_IS_PRIMARY(info) ? "ln8000" : "ln8000-secondary"), NULL);
+	if (!info->debug_root) {
+		ln_err("unable to create debug dir\n");
+		return -ENOENT;
+	} else {
+		debugfs_create_x32("address", S_IFREG | S_IWUSR | S_IRUGO, info->debug_root, &(info->debug_address));
+		debugfs_create_file("data", S_IFREG | S_IWUSR | S_IRUGO, info->debug_root, info, &register_debug_ops);
+	}
+
+	return 0;
+}
+
+/**
+ * Support IRQ interface 
+ */
+static int ln8000_read_int_value(struct ln8000_info *info, u32 *reg_val)
+{
+	int ret;
+
+	/* pause INT updates */
+	ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1, 0x1);
+	mdelay(1);
+
+	ret = ln8000_read_reg(info, LN8000_REG_INT1, reg_val);
+
+	/* resume INT updates */
+	ln8000_update_reg(info, LN8000_REG_TIMER_CTRL, 0x1, 0x0);
+
+	return ret;
+}
+
+static void vac_ov_control_work(struct work_struct *work)
+{
+	struct ln8000_info *info = container_of(work, struct ln8000_info, vac_ov_work.work);
+	int i, cnt, adc_check_cnt, ta_detach_cnt, delay = 50;
+	u32 sys_st;
+	bool enable_vac_ov = 1;
+
+	adc_check_cnt = 0;
+	ta_detach_cnt = 0;
+	cnt = 10000 / delay;
+	for (i = 0; i < cnt; ++i) {
+		ln8000_get_adc_data(info, LN8000_ADC_CH_VIN, &info->vbus_uV);
+		ln8000_read_reg(info, LN8000_REG_SYS_STS, &sys_st);
+
+		if (enable_vac_ov) {
+			/* Check ADC_VIN during the 10sec, if vin higher then 10V, disable to vac_ov */
+			if (info->vbus_uV > 10000000) {
+				adc_check_cnt += 1;
+				ln_info("vin=%dmV, adc_check_cnt=%d\n", info->vbus_uV/1000, adc_check_cnt);
+				if (adc_check_cnt > 2) {
+				enable_vac_ov = 0;
+				ln8000_enable_vac_ov(info, enable_vac_ov);
+				ln_info("vac_ov=disable, vin=%dmV, i=%d, cnt=%d, delay=%d\n", info->vbus_uV/1000, i, cnt, delay);
+					adc_check_cnt = 0;
+				}
+			}
+		} else {
+			/* After disabled vac_ov, if ADC_VIN lower then 7V goto the terminate work */
+			if (info->vbus_uV < 7000000) {
+					adc_check_cnt += 1;
+					ln_info("vin=%dmV, adc_check_cnt=%d\n", info->vbus_uV/1000, adc_check_cnt);
+						if (adc_check_cnt > 2) {
+				enable_vac_ov = 1;
+				ln_info("vac_ov=enable, vin=%dmV, i=%d, cnt=%d, delay=%d\n", info->vbus_uV/1000, i, cnt, delay);
+				goto teminate_work;
+			}
+		}
+		}
+		/* If judged 3 times by TA disconnected, goto the terminate work */
+		if (sys_st == 0x1) { /* it's means entered shutdown mode */
+			ta_detach_cnt += 1;
+			ln_info("sys_st=0x%x, ta_detached=%d\n", sys_st, ta_detach_cnt);
+				if (ta_detach_cnt > 2) {
+				goto teminate_work;
+			}
+		}
+
+		msleep(delay);
+	}
+
+teminate_work:
+	ln_info("terminate_work:enable_vac_ov (i=%d, cnt=%d)\n", i, cnt);
+	ln8000_enable_vac_ov(info, 1);
+	info->vac_ov_work_on = 0;
+}
+
+static void check_vac_ov_work(struct ln8000_info *info)
+{
+	u32 sys_st, fault1_st;
+
+	ln8000_read_reg(info, LN8000_REG_SYS_STS, &sys_st);
+	ln8000_read_reg(info, LN8000_REG_FAULT1_STS, &fault1_st);
+
+	if (sys_st == 0x02 && fault1_st == 0x00) {  /* connected valid VBUS */
+		if (info->vac_ov_work_on == 0) {		/* vac_ov_work not worked */
+			schedule_delayed_work(&info->vac_ov_work, msecs_to_jiffies(0));
+			info->vac_ov_work_on = 1;
+			ln_info("schedule_work : vac_ov_work\n");
+		}
+	}
+}
+
+static irqreturn_t ln8000_interrupt_handler(int irq, void *data)
+{
+	struct ln8000_info *info = data;
+	u32 int_reg, int_msk;
+	u8 masked_int;
+	int ret;
+	ln_err("ln8000_interrupt_handler enter!\n");
+	ret = ln8000_read_int_value(info, &int_reg);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		ln_err("fail to read INT reg (ret=%d)\n", ret);
+		return IRQ_NONE;
+	}
+	ln8000_read_reg(info, LN8000_REG_INT1_MSK, &int_msk);
+	masked_int = int_reg & ~int_msk;
+
+	ln_info("int_reg=0x%x, int_msk=0x%x, masked_int=0x%x\n", int_reg, int_msk, masked_int);
+
+	ln8000_print_regmap(info);
+	LN8000_BIT_CHECK(masked_int, 7, "(INT) FAULT_INT");
+	LN8000_BIT_CHECK(masked_int, 6, "(INT) NTC_PROT_INT");
+	LN8000_BIT_CHECK(masked_int, 5, "(INT) CHARGE_PHASE_INT");
+	LN8000_BIT_CHECK(masked_int, 4, "(INT) MODE_INT");
+	LN8000_BIT_CHECK(masked_int, 3, "(INT) REV_CURR_INT");
+	LN8000_BIT_CHECK(masked_int, 2, "(INT) TEMP_INT");
+	LN8000_BIT_CHECK(masked_int, 1, "(INT) ADC_DONE_INT");
+	LN8000_BIT_CHECK(masked_int, 0, "(INT) TIMER_INT");
+	ln8000_check_status(info);
+
+	if (masked_int & LN8000_MASK_FAULT_INT) { /* FAULT_INT */
+		if (info->volt_qual) {
+			ln_info("connected to power_supplier\n");
+		} else {
+			ln_info("FAULT_INT has occurred\n");
+		}
+	}
+	if (masked_int & LN8000_MASK_NTC_PROT_INT) { /* NTC_PROT_INT */
+		ln_info("NTC_PROT_INT has occurred(ntc_fault=%d, ntc_alarm=%d)\n", 
+				info->tbus_tbat_fault, info->tbus_tbat_alarm);
+	}
+	if (masked_int & LN8000_MASK_CHARGE_PHASE_INT) { /* CHARGE_PHASE_INT */
+	   if (info->vbat_regulated) {
+		   ln_info("CHARGE_PHASE_INT: VFLOAT regulated\n");
+	   } else if (info->iin_regulated) {
+		   ln_info("CHARGE_PHASE_INT: IIN regulated\n");
+	   }
+	}
+	if (masked_int & LN8000_MASK_MODE_INT) { /* MODE_INT */
+		switch(info->pwr_status) {
+		case LN8000_MASK_BYPASS_ENABLED:
+			ln_info("MODE_INT: device in BYPASS mode\n");
+			break;
+		case LN8000_MASK_SWITCHING_ENABLED:
+			ln_info("MODE_INT: device in SWITCHING mode\n");
+			break;
+		case LN8000_MASK_STANDBY_STS:
+			ln_info("MODE_INT: device in STANDBY mode\n");
+			break;
+		case LN8000_MASK_SHUTDOWN_STS:
+			ln_info("MODE_INT: device in SHUTDOWN mode\n");
+			break;
+		default:
+			ln_info("MODE_INT: device in  unknown mode\n");
+			break;
+		}
+	}
+	if (masked_int & LN8000_MASK_TEMP_INT) { /* TEMP_INT */
+		ln_info("TEMP_INT has occurred(tdie_fault=%d, tdie_alarm=%d)\n", 
+				info->tdie_fault, info->tdie_alarm);
+	}
+	if (masked_int & LN8000_MASK_TIMER_INT) { /* TIMER_INT */
+		ln_info("Watchdog timer has expired(wdt_fault=%d)\n", info->wdt_fault);
+	}
+
+	check_vac_ov_work(info);
+
+	return IRQ_HANDLED;
+}
+
+static int ln8000_irq_init(struct ln8000_info *info)
+{
+	const struct ln8000_platform_data *pdata = info->pdata;
+	int ret;
+	u8 mask;
+	u32 int_reg;
+
+	if (LN8000_IS_PRIMARY(info)) {
+		if (info->pdata->irq_gpio) {
+		   info->client->irq = gpiod_to_irq(pdata->irq_gpio);
+		   if (info->client->irq < 0) {
+			   ln_err("fail to get irq from gpio(irq_gpio=%p)\n", pdata->irq_gpio)
+			   info->client->irq = 0;
+			   return -EINVAL;
+		   }
+		   ln_info("mapped GPIO to irq (%d)\n", info->client->irq);
+		}
+	}  else {
+	   /* grab IRQ from primary device */
+	   ln_info("mapped shared GPIO to (primary dev) irq (%d)\n", info->client->irq);
+	}
+	/* interrupt mask setting */
+	mask = LN8000_MASK_ADC_DONE_INT | LN8000_MASK_TIMER_INT | LN8000_MASK_MODE_INT | LN8000_MASK_REV_CURR_INT;
+	if (info->pdata->tdie_prot_disable && info->pdata->tdie_reg_disable)
+	  mask |= LN8000_MASK_TEMP_INT;
+	if (info->pdata->iin_reg_disable && info->pdata->vbat_reg_disable)
+	  mask |= LN8000_MASK_CHARGE_PHASE_INT;
+	if (info->pdata->tbat_mon_disable && info->pdata->tbus_mon_disable)
+		mask |= LN8000_MASK_NTC_PROT_INT;
+	ln8000_write_reg(info, LN8000_REG_INT1_MSK, mask);
+	/* read clear int_reg */
+	ret = ln8000_read_int_value(info, &int_reg);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		ln_err("fail to read INT reg (ret=%d)\n", ret);
+		return IRQ_NONE;
+	}
+	ln_info("int1_msk=0x%x\n", mask);
+
+	return 0;
+}
+
+static void determine_initial_status(struct ln8000_info *info)
+{
+	if (info->client->irq)
+		ln8000_interrupt_handler(info->client->irq, info);
+}
+
+static const struct regmap_config ln8000_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= LN8000_REG_BC_STS_E,
+};
+
+static int ln8000_parse_dt(struct ln8000_info *info)
+{
+	struct device *dev = info->dev;
+	struct ln8000_platform_data *pdata = info->pdata;
+	struct device_node *np = dev->of_node;
+	u32 prop;
+	int ret;
+
+	if (np == NULL)
+	   return -EINVAL;
+
+	/* first we try to used client->irq */
+	if (info->client->irq == 0) {
+		/* sencond we try to used irq_index info */
+		ret = of_property_read_u32(np, "ln8000_charger,irq_index", &prop);
+		if (ret < 0) {
+			ln_err("can't get irq_index(ret=%d)\n", ret);
+			prop = 0;
+		}
+		info->client->irq = prop;
+	}
+	ln_info("info->client->irq=%d\n", info->client->irq);
+
+	if (!info->client->irq) {
+		pdata->irq_gpio = gpiod_get(dev, "irqb", GPIOD_IN);
+		if (LN8000_USE_GPIO(pdata)) {
+		   ln_info("[gpio] found valid GPIO/IRQ descriptor\n");
+		} else {
+		   ln_info("[gpio] unspecified or invalid GPIO descriptor\n");
+		   pdata->irq_gpio = 0;
+		}
+	}
+
+	/* device configuration */
+	ret = of_property_read_u32(np, "ln8000_charger,bat-ovp-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bat_ovp_th, (prop*1000/*uV*/), LN8000_BAT_OVP_DEFAULT);
+	ret = of_property_read_u32(np, "ln8000_charger,bat-ovp-alarm-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bat_ovp_alarm_th, (prop*1000/*uV*/), 0);
+	ret = of_property_read_u32(np, "ln8000_charger,bus-ovp-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bus_ovp_th, (prop*1000/*uV*/), LN8000_BUS_OVP_DEFAULT);
+	ret = of_property_read_u32(np, "ln8000_charger,bus-ovp-alarm-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bus_ovp_alarm_th, (prop*1000/*uA*/), 0);
+	ret = of_property_read_u32(np, "ln8000_charger,bus-ocp-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bus_ocp_th, (prop*1000/*uA*/), LN8000_BUS_OCP_DEFAULT);
+	ret = of_property_read_u32(np, "ln8000_charger,bus-ocp-alarm-threshold", &prop);
+	LN8000_PARSE_PROP(ret, pdata, bus_ocp_alarm_th, (prop*1000/*uA*/), 0);
+	ret = of_property_read_u32(np, "ln8000_charger,ntc-alarm-cfg", &prop);
+	LN8000_PARSE_PROP(ret, pdata, ntc_alarm_cfg, prop, LN8000_NTC_ALARM_CFG_DEFAULT);
+
+	/* protection/alarm disable (defaults to enable) */
+	pdata->vbat_ovp_disable	 = of_property_read_bool(np, "ln8000_charger,vbat-ovp-disable");
+	pdata->vbat_reg_disable	 = of_property_read_bool(np, "ln8000_charger,vbat-reg-disable");
+	pdata->iin_ocp_disable	  = of_property_read_bool(np, "ln8000_charger,iin-ocp-disable");
+	pdata->iin_reg_disable	  = of_property_read_bool(np, "ln8000_charger,iin-reg-disable");
+	pdata->tbus_mon_disable	 = of_property_read_bool(np, "ln8000_charger,tbus-mon-disable");
+	pdata->tbat_mon_disable	 = of_property_read_bool(np, "ln8000_charger,tbat-mon-disable");
+	pdata->tdie_prot_disable	= of_property_read_bool(np, "ln8000_charger,tdie-prot-disable");
+	pdata->tdie_reg_disable	 = of_property_read_bool(np, "ln8000_charger,tdie-reg-disable");
+	pdata->revcurr_prot_disable = of_property_read_bool(np, "ln8000_charger,revcurr-prot-disable");
+
+	/* override device tree */
+	if (info->dev_role == LN_PRIMARY) {
+	   ln_info("disable TS_BAT monitor for primary device on dual-mode\n");
+	   pdata->tbat_mon_disable = true;
+	} else {
+	   ln_info("disable VBAT_OVP and TS_BAT for secondary device on dual-mode\n");
+	   pdata->vbat_ovp_disable   = true;
+	   pdata->tbat_mon_disable   = true;
+	}
+
+	ln_info("vbat_ovp_disable = %d\n", pdata->vbat_ovp_disable);
+	ln_info("vbat_reg_disable = %d\n", pdata->vbat_reg_disable);
+	ln_info("iin_ocp_disable = %d\n", pdata->iin_ocp_disable);
+	ln_info("iin_reg_disable = %d\n", pdata->iin_reg_disable);
+	ln_info("tbus_mon_disable = %d\n", pdata->tbus_mon_disable);
+	ln_info("tbat_mon_disable = %d\n", pdata->tbat_mon_disable);
+	ln_info("tdie_prot_disable = %d\n", pdata->tdie_prot_disable);
+	ln_info("tdie_reg_disable = %d\n", pdata->tdie_reg_disable);
+	ln_info("revcurr_prot_disable = %d\n", pdata->revcurr_prot_disable);
+
+	return 0;
+}
+
+static const struct power_supply_desc ln8000_charger_desc = {
+	.name = "ln8000-charger",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.properties = ln8000_charger_props,
+	.num_properties = ARRAY_SIZE(ln8000_charger_props),
+	.get_property = ln8000_charger_get_property,
+	.set_property = ln8000_charger_set_property,
+	.property_is_writeable = ln8000_charger_is_writeable,
+};
+
+static struct power_supply_desc ln8000_battery_desc = {
+	.name			= "ln8000-battery",
+	.type			= POWER_SUPPLY_TYPE_BATTERY,
+	.get_property		= ln8000_get_battery_property,
+	.properties		= ln8000_battery_props,
+	.num_properties		= ARRAY_SIZE(ln8000_battery_props),
+};
+
+static int ln8000_psy_register(struct ln8000_info *info)
+{
+	struct power_supply_config psy_cfg = {
+		.of_node = info->client->dev.of_node,
+		.drv_data = info,
+	};
+
+	info->charger = devm_power_supply_register(&info->client->dev,
+				&ln8000_charger_desc, &psy_cfg);
+	if (IS_ERR(info->charger)) {
+	   ln_err("(%s) failed to register power supply\n", LN8000_ROLE(info));
+	   return PTR_ERR(info->charger);
+	}
+
+	info->battery = devm_power_supply_register(&info->client->dev,
+				&ln8000_battery_desc, &psy_cfg);
+	if (IS_ERR(info->battery)) {
+	   ln_err("(%s) failed to register power supply\n", LN8000_ROLE(info));
+	   return PTR_ERR(info->battery);
+	}
+
+	ln_info("(%s) successfully registered power supply\n", LN8000_ROLE(info));
+
+	return 0;
+}
+
+static int ln8000_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ln8000_info *info;
+	int ret = 0;
+
+	/* detect device on connected i2c bus */
+	ret = i2c_smbus_read_byte_data(client, LN8000_REG_DEVICE_ID);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		dev_err(&client->dev, "fail to detect ln8000 on i2c_bus(addr=0x%x)\n", client->addr);
+		return -ENODEV;
+	}
+	dev_info(&client->dev, "device id=0x%x\n", ret);
+
+	info = devm_kzalloc(&client->dev, sizeof(struct ln8000_info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&client->dev, "%s: fail to alloc devm for ln8000_info\n", __func__);
+		return -ENOMEM;
+	}
+	info->dev_role = LN_PRIMARY;
+
+	info->pdata = devm_kzalloc(&client->dev, sizeof(struct ln8000_platform_data), GFP_KERNEL);
+	if (info->pdata == NULL) {
+		ln_err("fail to alloc devm for ln8000_platform_data\n");
+		return -ENOMEM;
+	}
+	info->dev = &client->dev;
+	info->client = client;
+	ret = ln8000_parse_dt(info);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		ln_err("fail to parsed dt\n");
+		goto err_devmem;
+	}
+
+	info->regmap = devm_regmap_init_i2c(client, &ln8000_regmap_config);
+	if (IS_ERR(info->regmap)) {
+		ln_err("fail to initialize regmap\n");
+		ret = PTR_ERR(info->regmap);
+		goto err_devmem;
+	}
+
+	mutex_init(&info->data_lock);
+	mutex_init(&info->i2c_lock);
+	mutex_init(&info->irq_lock);
+	i2c_set_clientdata(client, info);
+
+	ln8000_soft_reset(info);
+	ln8000_init_device(info);
+
+	ret = ln8000_psy_register(info);
+	if (ret) {
+		goto err_cleanup;
+	}
+
+	ret = ln8000_irq_init(info);
+	if (ret < 0) {
+		goto err_cleanup;
+	}
+
+	if (client->irq) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq,
+					NULL, ln8000_interrupt_handler,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"ln8000-charger-irq", info);
+		if (ret < 0) {
+			ln_err("request irq for irq=%d failed, ret =%d\n",
+						client->irq, ret);
+			goto err_wakeup;
+		}
+		enable_irq_wake(client->irq);
+		INIT_DELAYED_WORK(&info->vac_ov_work, vac_ov_control_work);
+	} else {
+		ln_info("don't support isr(irq=%d)\n", info->client->irq);
+	}
+
+	device_init_wakeup(info->dev, 1);
+
+	ret = ln8000_create_debugfs_entries(info);
+	if (IS_ERR_VALUE((unsigned long)ret)) {
+		goto err_wakeup;
+	}
+
+	determine_initial_status(info);
+	ln8000_change_opmode(info, LN8000_OPMODE_STANDBY);
+
+	return 0;
+
+err_wakeup:
+	if (LN8000_IS_PRIMARY(info) && client->irq) {
+		if (info->pdata->irq_gpio) {
+			gpiod_put(info->pdata->irq_gpio);
+		}
+	}
+
+err_cleanup:
+	i2c_set_clientdata(client, NULL);
+	mutex_destroy(&info->data_lock);
+	mutex_destroy(&info->i2c_lock);
+	mutex_destroy(&info->irq_lock);
+err_devmem:
+
+	return ret;
+}
+
+static void ln8000_remove(struct i2c_client *client)
+{
+	struct ln8000_info *info = i2c_get_clientdata(client);
+
+	ln8000_change_opmode(info, LN8000_OPMODE_STANDBY);
+
+	debugfs_remove_recursive(info->debug_root);
+
+	if (client->irq) {
+		//free_irq(client->irq, info);
+		if (info->pdata->irq_gpio) {
+			gpiod_put(info->pdata->irq_gpio);
+		}
+	}
+
+	i2c_set_clientdata(info->client, NULL);
+
+	mutex_destroy(&info->data_lock);
+	mutex_destroy(&info->i2c_lock);
+	mutex_destroy(&info->irq_lock);
+}
+
+static void ln8000_shutdown(struct i2c_client *client)
+{
+	struct ln8000_info *info = i2c_get_clientdata(client);
+
+	ln8000_change_opmode(info, LN8000_OPMODE_STANDBY);
+}
+
+#if defined(CONFIG_PM)
+static int ln8000_suspend(struct device *dev)
+{
+	struct ln8000_info *info = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) && info->client->irq)
+		enable_irq_wake(info->client->irq);
+
+	ln8000_irq_sleep(info, 1);
+
+	return 0;
+}
+
+static int ln8000_resume(struct device *dev)
+{
+	struct ln8000_info *info = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) && info->client->irq)
+		disable_irq_wake(info->client->irq);
+
+	ln8000_irq_sleep(info, 0);
+
+	return 0;
+}
+
+static const struct dev_pm_ops ln8000_pm_ops = {
+	.suspend	= ln8000_suspend,
+	.resume		= ln8000_resume,
+};
+#endif
+
+static const struct of_device_id ln8000_of_match[] = {
+	{ .compatible = "lionsemi,ln8000", },
+	{ .compatible = "lionsemi,ln8000-secondary", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ln8000_of_match);
+
+static const struct i2c_device_id ln8000_i2c_ids[] = {
+	{ "ln8000", LN_PRIMARY },
+	{ "ln8000-secondary", LN_SECONDARY },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ln8000_i2c_ids);
+
+static struct i2c_driver ln8000_driver = {
+	.driver   = {
+		.name = "ln8000_charger",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ln8000_of_match),
+#if defined(CONFIG_PM)
+		.pm   = &ln8000_pm_ops,
+#endif
+	},
+	.probe	= ln8000_probe,
+	.remove   = ln8000_remove,
+	.shutdown = ln8000_shutdown,
+	.id_table = ln8000_i2c_ids,
+};
+module_i2c_driver(ln8000_driver);
+
+MODULE_AUTHOR("sungdae choi<sungdae@lionsemi.com>");
+MODULE_DESCRIPTION("LIONSEMI LN8000 charger driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.3.0");
diff --git a/drivers/power/supply/ln8000_charger.h b/drivers/power/supply/ln8000_charger.h
new file mode 100644
index 000000000..772f8852f
--- /dev/null
+++ b/drivers/power/supply/ln8000_charger.h
@@ -0,0 +1,320 @@
+/*
+ * ln8000-charger.h - Charger driver for LIONSEMI LN8000
+ *
+ * Copyright (C) 2021 Lion Semiconductor Inc.
+ * Copyright (C) 2021 XiaoMi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __LN8000_CHARGER_H__
+#define __LN8000_CHARGER_H__
+
+//#define LN8000_DUAL_CONFIG	/* uncomment to enable DUAL chip operation */
+//#define LN8000_DEBUG_SUPPORT
+
+#define LN8000_MANUFACTURER "Cirrus Logic"
+
+/**
+ * ln8000 device descripion definition 
+ */
+#define ASSIGNED_BITS(_end, _start) ((BIT(_end) - BIT(_start)) + BIT(_end))
+
+#define LN8000_REG_DEVICE_ID			0x00
+#define LN8000_REG_INT1			0x01
+#define LN8000_REG_INT1_MSK			0x02
+#define LN8000_REG_SYS_STS			0x03
+#define LN8000_REG_SAFETY_STS			0x04
+#define LN8000_REG_FAULT1_STS			0x05
+#define LN8000_REG_FAULT2_STS			0x06
+#define LN8000_REG_CURR1_STS			0x07
+#define LN8000_REG_ADC01_STS			0x09
+#define LN8000_REG_ADC02_STS			0x0a
+#define LN8000_REG_ADC03_STS			0x0b
+#define LN8000_REG_ADC04_STS			0x0c
+#define LN8000_REG_ADC06_STS			0x0e
+#define LN8000_REG_ADC07_STS			0x0f
+#define LN8000_REG_ADC08_STS			0x10
+#define LN8000_REG_ADC09_STS			0x11
+#define LN8000_REG_IIN_CTRL			0x1b
+#define LN8000_REG_REGULATION_CTRL			0x1c
+#define LN8000_REG_SYS_CTRL			0x1e
+#define LN8000_REG_GLITCH_CTRL			0x20
+#define LN8000_REG_FAULT_CTRL			0x21
+#define LN8000_REG_NTC_CTRL			0x22
+#define LN8000_REG_ADC_CTRL			0x23
+#define LN8000_REG_ADC_CFG			0x24
+#define LN8000_REG_RECOVERY_CTRL			0x25
+#define LN8000_REG_TIMER_CTRL		0x26
+#define LN8000_REG_THRESHOLD_CTRL			0x27
+#define LN8000_REG_V_FLOAT_CTRL			0x28
+#define LN8000_REG_CHARGE_CTRL			0x29
+#define LN8000_REG_LION_CTRL			0x30
+#define LN8000_REG_BC_OP_2			0x42
+
+#define LN8000_REG_BC_STS_E			0x4d
+
+/* register map description */
+#define LN8000_MASK_FAULT_INT			BIT(7)
+#define LN8000_MASK_NTC_PROT_INT			BIT(6)
+#define LN8000_MASK_CHARGE_PHASE_INT			BIT(5)
+#define LN8000_MASK_MODE_INT			BIT(4)
+#define LN8000_MASK_REV_CURR_INT			BIT(3)
+#define LN8000_MASK_TEMP_INT			BIT(2)
+#define LN8000_MASK_ADC_DONE_INT			BIT(1)
+#define LN8000_MASK_TIMER_INT			BIT(0)
+
+#define LN8000_MASK_IIN_LOOP_STS			BIT(7)
+#define LN8000_MASK_VFLOAT_LOOP_STS			BIT(6)
+#define LN8000_MASK_BYPASS_ENABLED			BIT(3)
+#define LN8000_MASK_SWITCHING_ENABLED			BIT(2)
+#define LN8000_MASK_STANDBY_STS			BIT(1)
+#define LN8000_MASK_SHUTDOWN_STS			BIT(0)
+
+#define LN8000_MASK_TEMP_MAX_STS			BIT(6)
+#define LN8000_MASK_TEMP_REGULATION_STS			BIT(5)
+#define LN8000_MASK_NTC_ALARM_STS			BIT(4)
+#define LN8000_MASK_NTC_SHUTDOWN_STS			BIT(3)
+#define LN8000_MASK_REV_IIN_STS			BIT(2)
+
+#define LN8000_MASK_WATCHDOG_TIMER_STS			BIT(7)
+#define LN8000_MASK_VBAT_OV_STS			BIT(6)
+#define LN8000_MASK_VAC_UNPLUG_STS			BIT(4)
+#define LN8000_MASK_VAC_OV_STS			BIT(3)
+#define LN8000_MASK_VIN_OV_STS			BIT(1)
+#define LN8000_MASK_VFAULTS			ASSIGNED_BITS(6,0)
+
+#define LN8000_MASK_VAC_UNPLUG_STS			BIT(4)
+#define LN8000_MASK_VIN_OV_STS			BIT(1)
+
+#define LN8000_MASK_IIN_OC_DETECTED			BIT(7)
+
+#define LN8000_MASK_VBAT_MIN_OK_STS			BIT(7)
+#define LN8000_MASK_CHARGE_TERM_STS			BIT(5)
+#define LN8000_MASK_RECHARGE_STS			BIT(4)
+
+enum ln8000_regulation_ctrl_desc {
+    LN8000_BIT_ENABLE_VFLOAT_LOOP_INT   = 7,
+    LN8000_BIT_ENABLE_IIN_LOOP_INT      = 6,
+    LN8000_BIT_DISABLE_VFLOAT_LOOP      = 5,
+    LN8000_BIT_DISABLE_IIN_LOOP         = 4,
+    LN8000_BIT_TEMP_MAX_EN              = 2,
+    LN8000_BIT_TEMP_REG_EN              = 1,
+};
+
+enum ln8000_sys_ctrl_desc {
+    LN8000_BIT_STANDBY_EN               = 3,
+    LN8000_BIT_REV_IIN_DET              = 2,
+    LN8000_BIT_EN_1TO1                  = 0,
+};
+
+enum ln8000_fault_ctrl_desc {
+    LN8000_BIT_DISABLE_IIN_OCP          = 6,
+    LN8000_BIT_DISABLE_VBAT_OV          = 5,
+    LN8000_BIT_DISABLE_VAC_OV           = 4,
+    LN8000_BIT_DISABLE_VAC_UV           = 3,
+    LN8000_BIT_DISABLE_VIN_OV           = 2,
+};
+
+/* device feature configuration desc */
+#define LN8000_DEVICE_ID    0x42
+
+enum ln8000_role {
+    LN_PRIMARY              = 0x0,
+    LN_SECONDARY            = 0x1,
+};
+
+enum ln8000_opmode_{
+    LN8000_OPMODE_UNKNOWN   = 0x0,
+    LN8000_OPMODE_STANDBY   = 0x1,
+    LN8000_OPMODE_BYPASS    = 0x2,
+    LN8000_OPMODE_SWITCHING = 0x3,
+};
+
+enum ln8000_vac_ov_cfg_desc {
+    LN8000_VAC_OVP_6P5V     = 0x0,
+    LN8000_VAC_OVP_11V      = 0x1,
+    LN8000_VAC_OVP_12V      = 0x2,
+    LN8000_VAC_OVP_13V      = 0x3,
+};
+
+enum ln8000_watchdpg_cfg_desc {
+    LN8000_WATCHDOG_5SEC    = 0x0,
+    LN8000_WATCHDOG_10SEC   = 0x1,
+    LN8000_WATCHDOG_20SEC   = 0x2,
+    LN8000_WATCHDOG_40SEC   = 0x3,
+    LN8000_WATCHDOG_MAX
+};
+
+enum ln8000_adc_channel_index {
+    LN8000_ADC_CH_VOUT      = 1,
+    LN8000_ADC_CH_VIN,
+    LN8000_ADC_CH_VBAT,
+    LN8000_ADC_CH_VAC,
+    LN8000_ADC_CH_IIN,
+    LN8000_ADC_CH_DIETEMP,
+    LN8000_ADC_CH_TSBAT,
+    LN8000_ADC_CH_TSBUS,
+    LN8000_ADC_CH_ALL
+};
+
+enum ln8000_adc_mode_desc {     /* used FORCE_ADC_MODE + ADC_SHUTDOWN_CFG */
+    ADC_AUTO_HIB_MODE       = 0x0,
+    ADC_AUTO_SHD_MODE       = 0x1,
+    ADC_SHUTDOWN_MODE       = 0x2,
+    ADC_HIBERNATE_MODE      = 0x4,
+    ADC_NORMAL_MODE         = 0x6,
+};
+
+enum ln8000_adc_hibernate_delay_desc {
+    ADC_HIBERNATE_500MS     = 0x0,
+    ADC_HIBERNATE_1S        = 0x1,
+    ADC_HIBERNATE_2S        = 0x2,
+    ADC_HIBERNATE_4S        = 0x3,
+};
+
+/* electrical numeric calculation unit description */
+#define LN8000_VBAT_FLOAT_MIN           3725000     /* unit = uV */
+#define LN8000_VBAT_FLOAT_MAX           5000000
+#define LN8000_VBAT_FLOAT_LSB           5000
+#define LN8000_ADC_VOUT_STEP	        5000        /* 5mV= 5000uV LSB	(0V ~ 5.115V) */
+#define LN8000_ADC_VIN_STEP             16000       /* 16mV=16000uV LSB	(0V ~ 16.386V) */
+#define LN8000_ADC_VBAT_STEP	        5000        /* 5mV= 5000uV LSB	(0V ~ 5.115V) */
+#define LN8000_ADC_VBAT_MIN             1000000     /* 1V */
+#define LN8000_ADC_VAC_STEP             16000       /* 16mV=16000uV LSB	(0V ~ 16.386V) */
+#define LN8000_ADC_VAC_OS               5	        
+#define LN8000_ADC_IIN_STEP             4890        /* 4.89mA=4890uA LSB	(0A ~ 5A) */
+#define LN8000_ADC_DIETEMP_STEP	        4350        /* 0.435C LSB = 4350dC/1000 (-25C ~ 160C) */
+#define LN8000_ADC_DIETEMP_DENOM        1000        /* 1000 */
+#define LN8000_ADC_DIETEMP_MIN	        (-250)      /* -25C = -250dC */
+#define LN8000_ADC_DIETEMP_MAX	        1600        /* 160C = 1600dC */
+#define LN8000_ADC_NTCV_STEP	        2933        /* 2.933mV=2933uV LSB	(0V ~ 3V) */
+#define LN8000_IIN_CFG_MIN              500000      /* 500mA=500,000uA */
+#define LN8000_IIN_CFG_LSB              50000       /* 50mA=50,000uA */
+
+/* device default values */
+#define LN8000_BAT_OVP_DEFAULT          4440000
+#define LN8000_BUS_OVP_DEFAULT          9500000
+#define LN8000_BUS_OCP_DEFAULT          2000000
+
+#define LN8000_NTC_ALARM_CFG_DEFAULT    226         /* NTC alarm threshold (~40C) */
+#define LN8000_NTC_SHUTDOWN_CFG         2           /* NTC shutdown config (-16LSB ~ 4.3C) */
+#define LN8000_DEFAULT_FSW_CFG          8           /* 8=440kHz, switching freq */
+#define LN8000_IIN_CFG_DEFAULT          2000000     /* 2A=2,000,000uA, input current limit */
+
+/* bus protection values for QC */
+#define BUS_OVP_FOR_QC                  13000000 /* ln8000 didn't used 10V, (support tot 6.5V, 11V, 12V, 13V) */
+#define BUS_OVP_ALARM_FOR_QC			9500000
+#define BUS_OCP_FOR_QC_CLASS_A			3250000
+#define BUS_OCP_ALARM_FOR_QC_CLASS_A    2000000
+#define BUS_OCP_FOR_QC_CLASS_B			3750000
+#define BUS_OCP_ALARM_FOR_QC_CLASS_B	2800000
+#define BUS_OCP_FOR_QC3P5_CLASS_A		3000000
+#define BUS_OCP_ALARM_FOR_QC3P5_CLASS_A	2500000
+#define BUS_OCP_FOR_QC3P5_CLASS_B		3500000
+#define BUS_OCP_ALARM_FOR_QC3P5_CLASS_B	3200000
+
+/**
+ * driver instance structure definition
+ */
+struct ln8000_platform_data {
+    struct gpio_desc *irq_gpio;     /* GPIO pin for (generic/power-on) interrupt  */
+
+    /* feature configuration */
+    unsigned int bat_ovp_th;        /* battery ovp threshold (mV) */
+    unsigned int bat_ovp_alarm_th;  /* battery ovp alarm threshold (mV) */
+    unsigned int bus_ovp_th;        /* IIN ovp threshold (mV) */
+    unsigned int bus_ovp_alarm_th;  /* IIN ovp alarm threshold (mV) */
+    unsigned int bus_ocp_th;        /* IIN ocp threshold (mA) */
+    unsigned int bus_ocp_alarm_th;  /* IIN ocp alarm threshold */
+    unsigned int ntc_alarm_cfg;     /* input/battery NTC voltage threshold code: 0~1023 */
+
+    /* protection enable/disable */
+    bool vbat_ovp_disable;          /* disable battery voltage OVP */
+    bool vbat_reg_disable;          /* disable battery voltage (float) regulation */
+    bool iin_ocp_disable;           /* disable input current OCP */
+    bool iin_reg_disable;           /* disable input current regulation */
+    bool tbus_mon_disable;          /* disable BUS temperature monitor (prot/alarm) */
+    bool tbat_mon_disable;          /* disable BAT temperature monitor (prot/alarm) */
+    bool tdie_prot_disable;         /* disable die temperature protection */
+    bool tdie_reg_disable;          /* disable die temperature regulation */
+    bool revcurr_prot_disable;      /* disable reverse current protection */
+};
+
+struct ln8000_info {
+	struct device *dev;
+	struct i2c_client *client;
+	struct ln8000_platform_data *pdata;
+	struct power_supply	*charger;
+	struct power_supply *battery;
+
+	struct mutex data_lock;
+	struct mutex i2c_lock;
+	struct mutex irq_lock;
+	struct regmap *regmap;
+
+	unsigned int op_mode;       /* target operation mode */
+	unsigned int pwr_status;    /* current device status */
+	unsigned int dev_role;      /* device role */
+
+	/* system/device status */
+	bool vbat_regulated;        /* vbat loop is active (+ OV alarm) */
+	bool iin_regulated;         /* iin loop is active (+ OC alarm) */
+	bool tdie_fault;            /* die temperature fault */
+	bool tbus_tbat_fault;       /* BUS/BAT temperature fault */
+	bool tdie_alarm;            /* die temperature alarm (regulated) */
+	bool tbus_tbat_alarm;       /* BUS/BAT temperature alarm */
+	bool wdt_fault;             /* watchdog timer expiration */
+	bool vbat_ov;               /* vbat OV fault */
+	bool vac_ov;                /* vac OV fault */
+	bool vbus_ov;               /* vbus OV fault */
+	bool iin_oc;                /* iin OC fault */
+	bool vac_unplug;            /* vac unplugged */
+	bool iin_rc;                /* iin reverse current detected */
+	bool volt_qual;             /* all voltages are qualified */
+	bool usb_present;           /* usb plugged (present) */
+	bool chg_en;                /* charging enavbled */
+	bool rcp_en;                /* reverse current protection enabled */
+	int vbat_ovp_alarm_th;      /* vbat ovp alarm threshold */
+	int vin_ovp_alarm_th;       /* vin ovp alarm threshold */
+	int iin_ocp_alarm_th;       /* iin ocp alarm threshold */
+
+	/* ADC readings */
+	int	tbat_uV;                /* BAT temperature (NTC, uV) */
+	int	tbus_uV;                /* BUS temperature (NTC, uV) */
+	int	tdie_dC;                /* die temperature (deci-Celsius) */
+	int	vbat_uV;                /* battery voltage (uV) */
+	int	vbus_uV;                /* input voltage (uV) */
+	int	iin_uA;                 /* input current (uV) */
+
+	/* VAC_OV control for QC3 */
+	struct delayed_work vac_ov_work;
+	bool vac_ov_work_on;
+
+	/* for restore reg_init_val */
+	u32 regulation_ctrl;
+	u32 adc_ctrl;
+	u32 v_float_ctrl;
+	u32 charge_ctrl;
+
+	#ifdef LN8000_ROLE_MASTER
+	bool ibat_term;             /* battery current below termination threshold */
+	bool vbat_rechg;            /* battery voltage below recharge threshold */
+	bool vbat_min;              /* battery voltage above min. threshold */
+	#endif
+
+	/* debugfs */
+	struct dentry *debug_root;
+	u32 debug_address;
+};
+
+#endif  /* __LN8000_CHARGER_H__ */
-- 
2.34.1

