From 970538cd6fa3bd115237594e86f695bdc6701b62 Mon Sep 17 00:00:00 2001
From: maverick <maverick_jia@sina.com>
Date: Tue, 30 Jan 2024 14:42:38 +0800
Subject: [PATCH 39/45] USBPD: trick Xiaomi charger to supporting PPS

---
 drivers/usb/typec/tcpm/tcpm.c | 229 +++++++++++++++++++++-------------
 include/linux/usb/pd_vdo.h    |  14 +++
 2 files changed, 155 insertions(+), 88 deletions(-)

diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index 879ccbe20..204fd1817 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -137,6 +137,9 @@
 	S(GET_PPS_STATUS_SEND),			\
 	S(GET_PPS_STATUS_SEND_TIMEOUT),		\
 						\
+	S(GET_SOURCE_CAP),			\
+	S(GET_SOURCE_CAP_TIMEOUT),		\
+						\
 	S(GET_SINK_CAP),			\
 	S(GET_SINK_CAP_TIMEOUT),		\
 						\
@@ -559,11 +562,13 @@ static const char * const pd_rev[] = {
 
 #define tcpm_sink_tx_ok(port) \
 	(tcpm_port_is_sink(port) && \
-	((port)->cc1 == TYPEC_CC_RP_3_0 || (port)->cc2 == TYPEC_CC_RP_3_0))
+	((port)->cc1 >= TYPEC_CC_RP_DEF || (port)->cc2 >= TYPEC_CC_RP_DEF))
 
 #define tcpm_wait_for_discharge(port) \
 	(((port)->auto_vbus_discharge_enabled && !(port)->vbus_vsafe0v) ? PD_T_SAFE_0V : 0)
 
+static bool mi_adaptor_verified = false;
+
 static enum tcpm_state tcpm_default_state(struct tcpm_port *port)
 {
 	if (port->port_type == TYPEC_PORT_DRP) {
@@ -1592,6 +1597,69 @@ static void tcpm_register_partner_altmodes(struct tcpm_port *port)
 	}
 }
 
+static int tcpm_pd_uvdm(struct tcpm_port *port, const u32 *p,
+			int cnt, u32 *response)
+{
+	int cmd = UVDM_HDR_CMD(p[0]);
+	struct pd_mode_data *modep = &port->mode_data;
+	int rlen = 0;
+	int i;
+
+	tcpm_log(port, "Rx UVDM raw 0x%x cmd %d len %d", p[0], cmd, cnt);
+
+	for (i = 1; i < cnt; i++) {
+		tcpm_log(port, "object %d: 0x%x", i, p[i]);
+	}
+
+	switch (cmd) {
+	case USBPD_UVDM_CHARGER_VERSION:
+		response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+			  USBPD_UVDM_CHARGER_VOLTAGE);
+		rlen = 1;
+		break;
+	case USBPD_UVDM_CHARGER_VOLTAGE:
+		response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+			  USBPD_UVDM_CHARGER_TEMP);
+		rlen = 1;
+		break;
+	case USBPD_UVDM_CHARGER_TEMP:
+		response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+			  USBPD_UVDM_SESSION_SEED);
+		response[1] = 0x6019b457;
+		response[2] = 0xcd77fd5f;
+		response[3] = 0xedffdc3d;
+		response[4] = 0x0ed06106;
+		rlen = 5;
+		break;
+	case USBPD_UVDM_SESSION_SEED:
+		response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+			  USBPD_UVDM_AUTHENTICATION);
+		response[1] = 0x41dee8fa;
+		response[2] = 0x7d0aef33;
+		response[3] = 0xbd5d5f4e;
+		response[4] = 0x51e5a41f;
+		rlen = 5;
+		break;
+	case USBPD_UVDM_AUTHENTICATION:
+		response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+			  USBPD_UVDM_VERIFIED);
+		response[1] = 1;
+		rlen = 2;
+		break;
+	case USBPD_UVDM_VERIFIED:
+		if (port->data_role == TYPEC_HOST) {
+			port->upcoming_state = DR_SWAP_SEND;
+			tcpm_ams_start(port, DATA_ROLE_SWAP);
+			mi_adaptor_verified = true;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return rlen;
+}
+
 #define supports_modal(port)	PD_IDH_MODAL_SUPP((port)->partner_ident.id_header)
 
 static int tcpm_pd_svdm(struct tcpm_port *port, struct typec_altmode *adev,
@@ -1717,6 +1785,25 @@ static int tcpm_pd_svdm(struct tcpm_port *port, struct typec_altmode *adev,
 						  CMD_DISCOVER_MODES);
 				rlen = 1;
 			}
+
+			/* Mi charge adaptor */
+			if (port->partner_ident.id_header == 0x5802717) {
+				if (mi_adaptor_verified == false) {
+					modep->svids[0] = 0x2717;
+					modep->nsvids = 1;
+					if (port->data_role == TYPEC_DEVICE) {
+						port->upcoming_state = DR_SWAP_SEND;
+						tcpm_ams_start(port, DATA_ROLE_SWAP);
+					} else {
+						response[0] = UVDM_HDR(modep->svids[0], USBPD_UVDM_REQUEST,
+							  USBPD_UVDM_CHARGER_VERSION);
+						rlen = 1;
+					}
+				} else if (port->nr_source_caps == 4) {
+					port->upcoming_state = GET_SOURCE_CAP;
+					tcpm_ams_start(port, GET_SOURCE_CAPABILITIES);
+				}
+			}
 			break;
 		case CMD_DISCOVER_MODES:
 			/* 6.4.4.3.3 */
@@ -1833,6 +1920,9 @@ static void tcpm_handle_vdm_request(struct tcpm_port *port,
 		 */
 		port->vdm_sm_running = true;
 		rlen = tcpm_pd_svdm(port, adev, p, cnt, response, &adev_action);
+	} else if (!PD_VDO_SVDM(p[0]) && tcpm_vdm_ams(port)) {
+		port->vdm_sm_running = true;
+		rlen = tcpm_pd_uvdm(port, p, cnt, response);
 	} else {
 		if (port->negotiated_rev >= PD_REV30)
 			tcpm_pd_handle_msg(port, PD_MSG_CTRL_NOT_SUPP, NONE_AMS);
@@ -2009,6 +2099,25 @@ static void vdm_run_state_machine(struct tcpm_port *port)
 				break;
 			}
 
+			if (res < 0) {
+				port->vdm_state = VDM_STATE_ERR_BUSY;
+				return;
+			}
+		} else if (!PD_VDO_SVDM(vdo_hdr)) {
+			switch (PD_VDO_CMD(vdo_hdr)) {
+			case USBPD_UVDM_CHARGER_VERSION:
+			case USBPD_UVDM_CHARGER_VOLTAGE:
+			case USBPD_UVDM_CHARGER_TEMP:
+			case USBPD_UVDM_SESSION_SEED:
+			case USBPD_UVDM_AUTHENTICATION:
+			case USBPD_UVDM_VERIFIED:
+				res = tcpm_ams_start(port, UNSTRUCTURED_VDMS);
+				break;
+			default:
+				res = -EOPNOTSUPP;
+				break;
+			}
+
 			if (res < 0) {
 				port->vdm_state = VDM_STATE_ERR_BUSY;
 				return;
@@ -2342,6 +2451,7 @@ static void tcpm_pd_handle_state(struct tcpm_port *port,
 	switch (port->state) {
 	case SRC_READY:
 	case SNK_READY:
+	case GET_SOURCE_CAP:
 		port->ams = ams;
 		tcpm_set_state(port, state, delay_ms);
 		break;
@@ -3278,18 +3388,10 @@ static int tcpm_pd_select_pdo(struct tcpm_port *port, int *sink_pdo,
 
 static unsigned int tcpm_pd_select_pps_apdo(struct tcpm_port *port)
 {
-	unsigned int i, j, max_mw = 0, max_mv = 0;
-	unsigned int min_src_mv, max_src_mv, src_ma, src_mw;
-	unsigned int min_snk_mv, max_snk_mv;
-	unsigned int max_op_mv;
-	u32 pdo, src, snk;
-	unsigned int src_pdo = 0, snk_pdo = 0;
+	unsigned int i, src_ma, max_temp_mw = 0, max_op_ma, op_mw;
+	unsigned int src_pdo = 0;
+	u32 pdo, src;
 
-	/*
-	 * Select the source PPS APDO providing the most power while staying
-	 * within the board's limits. We skip the first PDO as this is always
-	 * 5V 3A.
-	 */
 	for (i = 1; i < port->nr_source_caps; ++i) {
 		pdo = port->source_caps[i];
 
@@ -3300,54 +3402,17 @@ static unsigned int tcpm_pd_select_pps_apdo(struct tcpm_port *port)
 				continue;
 			}
 
-			min_src_mv = pdo_pps_apdo_min_voltage(pdo);
-			max_src_mv = pdo_pps_apdo_max_voltage(pdo);
-			src_ma = pdo_pps_apdo_max_current(pdo);
-			src_mw = (src_ma * max_src_mv) / 1000;
-
-			/*
-			 * Now search through the sink PDOs to find a matching
-			 * PPS APDO. Again skip the first sink PDO as this will
-			 * always be 5V 3A.
-			 */
-			for (j = 1; j < port->nr_snk_pdo; j++) {
-				pdo = port->snk_pdo[j];
-
-				switch (pdo_type(pdo)) {
-				case PDO_TYPE_APDO:
-					if (pdo_apdo_type(pdo) != APDO_TYPE_PPS) {
-						tcpm_log(port,
-							 "Not PPS APDO (sink), ignoring");
-						continue;
-					}
-
-					min_snk_mv =
-						pdo_pps_apdo_min_voltage(pdo);
-					max_snk_mv =
-						pdo_pps_apdo_max_voltage(pdo);
-					break;
-				default:
-					tcpm_log(port,
-						 "Not APDO type (sink), ignoring");
-					continue;
-				}
+			if (port->pps_data.req_out_volt > pdo_pps_apdo_max_voltage(pdo) ||
+			    port->pps_data.req_out_volt < pdo_pps_apdo_min_voltage(pdo))
+				continue;
 
-				if (min_src_mv <= max_snk_mv &&
-				    max_src_mv >= min_snk_mv) {
-					max_op_mv = min(max_src_mv, max_snk_mv);
-					src_mw = (max_op_mv * src_ma) / 1000;
-					/* Prefer higher voltages if available */
-					if ((src_mw == max_mw &&
-					     max_op_mv > max_mv) ||
-					    src_mw > max_mw) {
-						src_pdo = i;
-						snk_pdo = j;
-						max_mw = src_mw;
-						max_mv = max_op_mv;
-					}
-				}
+			src_ma = pdo_pps_apdo_max_current(pdo);
+			max_op_ma = min(src_ma, port->pps_data.req_op_curr);
+			op_mw = max_op_ma * port->pps_data.req_out_volt / 1000;
+			if (op_mw > max_temp_mw) {
+				src_pdo = i;
+				max_temp_mw = op_mw;
 			}
-
 			break;
 		default:
 			tcpm_log(port, "Not APDO type (source), ignoring");
@@ -3357,16 +3422,10 @@ static unsigned int tcpm_pd_select_pps_apdo(struct tcpm_port *port)
 
 	if (src_pdo) {
 		src = port->source_caps[src_pdo];
-		snk = port->snk_pdo[snk_pdo];
-
-		port->pps_data.req_min_volt = max(pdo_pps_apdo_min_voltage(src),
-						  pdo_pps_apdo_min_voltage(snk));
-		port->pps_data.req_max_volt = min(pdo_pps_apdo_max_voltage(src),
-						  pdo_pps_apdo_max_voltage(snk));
-		port->pps_data.req_max_curr = min_pps_apdo_current(src, snk);
-		port->pps_data.req_out_volt = min(port->pps_data.req_max_volt,
-						  max(port->pps_data.req_min_volt,
-						      port->pps_data.req_out_volt));
+
+		port->pps_data.req_min_volt = pdo_pps_apdo_min_voltage(src);
+		port->pps_data.req_max_volt = pdo_pps_apdo_max_voltage(src);
+		port->pps_data.req_max_curr = pdo_pps_apdo_max_current(src);
 		port->pps_data.req_op_curr = min(port->pps_data.req_max_curr,
 						 port->pps_data.req_op_curr);
 	}
@@ -3484,32 +3543,16 @@ static int tcpm_pd_send_request(struct tcpm_port *port)
 static int tcpm_pd_build_pps_request(struct tcpm_port *port, u32 *rdo)
 {
 	unsigned int out_mv, op_ma, op_mw, max_mv, max_ma, flags;
-	enum pd_pdo_type type;
 	unsigned int src_pdo_index;
-	u32 pdo;
 
 	src_pdo_index = tcpm_pd_select_pps_apdo(port);
 	if (!src_pdo_index)
 		return -EOPNOTSUPP;
 
-	pdo = port->source_caps[src_pdo_index];
-	type = pdo_type(pdo);
-
-	switch (type) {
-	case PDO_TYPE_APDO:
-		if (pdo_apdo_type(pdo) != APDO_TYPE_PPS) {
-			tcpm_log(port, "Invalid APDO selected!");
-			return -EINVAL;
-		}
-		max_mv = port->pps_data.req_max_volt;
-		max_ma = port->pps_data.req_max_curr;
-		out_mv = port->pps_data.req_out_volt;
-		op_ma = port->pps_data.req_op_curr;
-		break;
-	default:
-		tcpm_log(port, "Invalid PDO selected!");
-		return -EINVAL;
-	}
+	max_mv = port->pps_data.req_max_volt;
+	max_ma = port->pps_data.req_max_curr;
+	out_mv = port->pps_data.req_out_volt;
+	op_ma = port->pps_data.req_op_curr;
 
 	flags = RDO_USB_COMM | RDO_NO_SUSPEND;
 
@@ -3811,6 +3854,7 @@ static void tcpm_reset_port(struct tcpm_port *port)
 	port->partner_source_caps = NULL;
 	usb_power_delivery_unregister(port->partner_pd);
 	port->partner_pd = NULL;
+	mi_adaptor_verified = false;
 }
 
 static void tcpm_detach(struct tcpm_port *port)
@@ -4929,6 +4973,15 @@ static void run_state_machine(struct tcpm_port *port)
 	case GET_PPS_STATUS_SEND_TIMEOUT:
 		tcpm_set_state(port, ready_state(port), 0);
 		break;
+	case GET_SOURCE_CAP:
+		usb_power_delivery_unregister_capabilities(port->partner_source_caps);
+		port->partner_source_caps = NULL;
+		tcpm_pd_send_control(port, PD_CTRL_GET_SOURCE_CAP);
+		tcpm_set_state(port, GET_SOURCE_CAP_TIMEOUT, PD_T_SENDER_RESPONSE);
+		break;
+	case GET_SOURCE_CAP_TIMEOUT:
+		tcpm_set_state(port, ready_state(port), 0);
+		break;
 	case GET_SINK_CAP:
 		tcpm_pd_send_control(port, PD_CTRL_GET_SINK_CAP);
 		tcpm_set_state(port, GET_SINK_CAP_TIMEOUT, PD_T_SENDER_RESPONSE);
diff --git a/include/linux/usb/pd_vdo.h b/include/linux/usb/pd_vdo.h
index b05725070..cb5c92579 100644
--- a/include/linux/usb/pd_vdo.h
+++ b/include/linux/usb/pd_vdo.h
@@ -58,6 +58,20 @@
 #define CMD_EXIT_MODE		5
 #define CMD_ATTENTION		6
 
+/* UVDM for Mi adaptor */
+#define USBPD_UVDM_CHARGER_VERSION	1
+#define USBPD_UVDM_CHARGER_VOLTAGE	2
+#define USBPD_UVDM_CHARGER_TEMP		3
+#define USBPD_UVDM_SESSION_SEED		4
+#define USBPD_UVDM_AUTHENTICATION	5
+#define USBPD_UVDM_VERIFIED			6
+
+#define UVDM_HDR(svid, cmd0, cmd1) \
+       (((svid) << 16) | (0 << 15) | ((cmd0) << 8) \
+       | (cmd1))
+#define UVDM_HDR_CMD(hdr)	((hdr) & 0xff)
+#define USBPD_UVDM_REQUEST		0x1
+
 #define VDO_CMD_VENDOR(x)    (((0x10 + (x)) & 0x1f))
 
 /* ChromeOS specific commands */
-- 
2.34.1

